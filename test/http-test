#!/usr/bin/perl -w
package Config;
use strict;
use threads;
use threads::shared;

use Getopt::Long qw(:config bundling);
use Pod::Usage;
use Data::Dumper;

# defaults and non-CLI settings
my %CONFIG = (
    listen_ip => '127.0.0.1',
    listen_port => '8080',
    proxy_address => 'localhost:9000',
    server_threads => 1,
    client_threads => 1
);

my %OPTIONS = (
    # Format:
    # name          => ['aliases', 'type', 'description', 'dashed_variant'(generated)]
    server_address  => ['s', '=s', 'Bind HTTP server to specified IP:PORT'],
    proxy_address   => ['p', '=s', 'IP:PORT of tested HTTP proxy'],
    no_proxy        => ['P', '', "Do not use proxy. Instead send requests directly to server."],
    server_threads  => ['W', '=i', "Number of worker threads to spawn"],
    client_threads  => ['C', '=i', "Number of client threads to spawn"],
    exit_running    => ['X', '', "If can't bind HTTP server, try to stop the running one"],
    verbose         => ['v', '+', 'Verbose operation'],
    dump            => ['D', '+', 'Dump state at certain runpoint'],
);

use constant {
    ALIASES     => 0,
    TYPE        => 1,
    DESCRIPTION => 2,
    DEFAULT     => 3,
    DASHED      => 4
};

my @GETOPT_OPTS = map {
    my $specifier = $_;
    my $dashed = $_;
    my $aliases = $OPTIONS{$_}->[ALIASES];

    $specifier .= "|${dashed}"
        if $dashed =~ s/_/-/g;
    $specifier .= "|${aliases}"
        if $aliases;
    $specifier .= $OPTIONS{$_}->[TYPE];

    $OPTIONS{$_}->[DASHED] = $dashed;
    $specifier
} keys %OPTIONS;

my $singleton;

sub get
{
    return $singleton
        if $singleton;

    my $class = shift;
    $class = (ref $class || $class || __PACKAGE__);

    $singleton = bless {} => $class;
    share ($singleton);
    %$singleton = %CONFIG;

    $singleton->get_options();
    return $singleton;
}

sub require_options
{
    my $c = shift;
    my @missed = grep {
        not defined $c->{$_}
    } @_;
    if (@missed) {
        die "Required options missed: ", join(", ", map("--$_", @missed)), "\n";
    }
}

sub dump
{
    my $c = shift;
    $c->{dump} or return $c;

    my @dump;
    my %save;
    while ($_ = shift) {
        if (! ref $_ && s/^-//) {
            $save{$_} = ${$Data::Dumper::{$_}};
            ${$Data::Dumper::{$_}} = shift;
            next;
        }
        push @dump, $_;
    }

    $c->{dump}--;
    for (@dump) {
        print Dumper($_);
    }
    if (!$c->{dump}) {
        exit 0;
    }

    for (keys %save) {
        ${$Data::Dumper::{$_}} = $save{$_};
    }

    return $c;
}

sub get_options
{
    my $c = shift;
    GetOptions ($c, @GETOPT_OPTS) or exit 1;

    if ($c->{help}) {
        tie *OUT, __PACKAGE__;
        my $fh = \*OUT;
        pod2usage(-output => $fh, -verbose => 99, -sections => 'SYNOPSIS|COMMANDS|OPTIONS');
    }

    $c->process_options();
    $c->dump($c);

    return $c;
}

sub process_options
{
    my $c = shift;
    if ($c->{server_address}) {
        my @l = split(':', $c->{server_address});
        $c->{listen_ip} = $l[0] if $l[0];
        $c->{listen_port} = $l[1] if $l[1];
    } else {
        $c->{server_address} = $c->{listen_ip}. ':'. $c->{listen_port};
    }
    if ($c->{no_proxy}) {
        undef $c->{proxy_address};
    }
}

sub url
{
    my $c = shift;
    my $key = shift;
    return "http://". $c->{$key}. "/";
}

1;

package Threads;
use strict;
use threads ('yield',
             'stack_size' => 64*4096,
             'exit' => 'threads_only',
             'stringify');

my @Threads;

sub start
{
    my $count = shift;
    for my $i (1..$count) {
        my $thr = threads->create(@_);
        push @Threads, $thr;
    }
}

sub join
{
    for my $thr (@Threads) {
        $thr->join();
    }
}

1;

package Server;
use strict;
use threads;
use threads::shared;
use Storable qw[freeze thaw];

use Data::Dumper;
use HTTP::Daemon;
use HTTP::Response;
use HTTP::Status;
use Errno qw[:POSIX];

my $RunS :shared;
my %Daemon :shared;
my $DaemonFD :shared;

sub start
{
    my $c = Config::get();
    my $d = HTTP::Daemon->new(
        LocalAddr => $c->{'listen_ip'},
        LocalPort => $c->{'listen_port'},
        ReuseAddr => 1
    ) or die $c->{server_address}. ": $!\n";

    %Daemon = %${\*$d};
    $DaemonFD = fileno($d);
    open SOCK, "+<&=$DaemonFD" or die $!;

    $RunS = 1;
    Threads::start(1, \&accept_thread);
    Threads::start($c->{server_threads}, \&worker_thread);
}

sub get_daemon
{
    open SOCK, "+<&=$DaemonFD" or die $!;
    my $d = bless \*SOCK => 'HTTP::Daemon';
    %${\*$d} = %Daemon;
    return $d;
}

sub get_conn
{
    my $daemon = shift;
    my $fd = shift;
    open FD, "+<&=$fd" or die $!;
    my $conn = bless \*FD => "HTTP::Daemon::ClientConn";
    %${\*$conn} = %Daemon;
    $${\*$conn}{httpd_daemon} = $daemon;
    return $conn;
}

my @Conn :shared;
my @Requests :shared;
my %Responses :shared;
my %ResponsesSent :shared;

sub accept_thread
{
    my $d = get_daemon();
    print "Started HTTP server at " . $d->url . "\n";

    while ($RunS) {
        my $conn = $d->accept;
        last if $!{EINVAL};
        die "accept: $!\n" unless $conn;
        {
            my $fd = fileno($conn);
            open FD, "+<&=$fd" or die $!;
            lock @Conn;
            push @Conn, $fd;
            cond_signal @Conn;
        }
    }
}

my $WorkerThreads :shared;
$WorkerThreads = 0;

sub worker_thread
{
    ++$WorkerThreads;
    my $d = get_daemon();

    loop:
    while ($RunS) {
        my $conn_fd;
        {
            lock @Conn;
            cond_wait @Conn
                until @Conn || !$RunS;
            last loop unless $RunS;
            $conn_fd = shift @Conn;
        }
        my $conn = get_conn($d, $conn_fd);
        my $req = $conn->get_request(1) or last;
        my $id = $req->header('X-Request-Id');
        {
            lock @Requests;
            push @Requests, freeze [$req, $id];
            cond_signal @Requests;
        }
        my $resp;
        my $resp_frozen;
        {
            lock %Responses;
            cond_wait %Responses
                until exists $Responses{$id} || !$RunS;
            last loop unless $RunS;
            $resp_frozen = $Responses{$id};
            delete $Responses{$id};
        }
        $resp = thaw $resp_frozen;
        $conn->send_response($resp);
        {
            lock %ResponsesSent;
            $ResponsesSent{$id} = $resp_frozen;
            cond_signal %ResponsesSent;
        }
        $conn->close(); # FIXME: keepalives
    }
    --$WorkerThreads;
}

use Time::HiRes 'usleep';

sub stop
{
    $RunS = 0;
    shutdown(get_daemon(), 2);
    while ($WorkerThreads) {
        {
            lock @Conn;
            cond_broadcast @Conn;
        }
        {
            lock %Responses;
            cond_broadcast %Responses;
        }
    } continue {
        usleep 1;
    }
}

sub get_request
{
    my $run = shift;
    my $req;
    my $id;
    {
        lock @Requests;
        cond_wait @Requests
            until @Requests || !$$run;
        return unless $$run;
        ($req, $id) = @{thaw shift @Requests};
    }
    return ($req, $id);
}

sub get_response
{
    my $run = shift;
    my $id = shift;
    my $resp;
    {
        lock %ResponsesSent;
        cond_wait %ResponsesSent
            until exists $ResponsesSent{$id} || !$$run;
        return unless $$run;
        $resp = thaw $ResponsesSent{$id};
        delete $ResponsesSent{$id};
    }
    return $resp;
}

sub broadcast
{
    {
        lock @Requests;
        cond_broadcast @Requests;
    }
    {
        lock %ResponsesSent;
        cond_broadcast %ResponsesSent;
    }
}

sub set_response
{
    my $resp = shift;
    my $id = shift;
    $resp->header('X-Request-Id', $id);
    {
        lock %Responses;
        $Responses{$id} = freeze $resp;
        cond_signal %Responses;
    }
    return $resp;
}

=pod
use constant HOSTNAME => qx{hostname};

@SIG{$_} = sub {
    $RUN = 0;
} for (qw[INT TERM HUP QUIT]);
=cut

1;

package Client;
use strict;
use LWP  5.825;
use threads;
use threads::shared;
use Storable qw[freeze thaw];

my $RunC :shared;

use constant MAX_REQS => 1000;
my @Reqs :shared;
my $ReqsFreed :shared;
my %ReqSent :shared;

my @Resps :shared;

sub start
{
    $RunC = 1;
    Threads::start(Config::get()->{client_threads}, \&client_thread);
}

my $ClientThreads :shared;
$ClientThreads = 0;

sub client_thread
{
    ++$ClientThreads;
    my $c = Config::get();
    my $ua = LWP::UserAgent->new;
    if ($c->{proxy_address}) {
        $ua->proxy('http', $c->url('proxy_address'));
    }

    $ua->add_handler(request_send => sub {
        my $req = $_[0];
        my $id = $req->header('X-Request-Id');
        lock %ReqSent;
        $ReqSent{$id} = freeze $req;
        cond_signal %ReqSent;
    });

    loop:
    while ($RunC) {
        my $req;
        {
            lock @Reqs;
            cond_wait @Reqs
                until @Reqs || !$RunC;
            last loop unless $RunC;
            $req = thaw(shift @Reqs);
            if (@Reqs == MAX_REQS - 1) {
                lock $ReqsFreed;
                cond_signal $ReqsFreed;
            }
        }

        my $resp = $ua->request($req);   #do it
        my $id = $resp->header('X-Request-Id');
        {
            lock @Resps;
            push @Resps, freeze [ $resp, $id ];
            cond_signal @Resps;
        }
    }
    --$ClientThreads;
}

use Time::HiRes 'usleep';

sub stop
{
    $RunC = 0;
    while ($ClientThreads) {
        lock @Reqs;
        cond_signal @Reqs;
    } continue {
        usleep 1;
    }
}

sub send_request
{
    my $req = shift;
    my $id = shift;
    $req->header('X-Request-Id' => $id);
    {
        lock @Reqs;
        cond_wait $ReqsFreed, @Reqs
            until @Reqs < MAX_REQS;
        push @Reqs, freeze $req;
        cond_signal @Reqs;
    }
}

sub get_request
{
    my $run = shift;
    my $id = shift;
    my $req_sent;
    {
        lock %ReqSent;
        until (exists $ReqSent{$id} || !$$run) {
            cond_wait %ReqSent;
        }
        return unless $$run;
        $req_sent = thaw $ReqSent{$id};
        delete $ReqSent{$id};
    }
    return $req_sent;
}

sub get_response
{
    my $run = shift;
    my $resp;
    my $id;
    {
        lock @Resps;
        until (@Resps || !$$run) {
            cond_wait @Resps;
        }
        return unless $$run;
        ($resp, $id) = @{thaw shift @Resps};
    }
    return ($resp, $id);
}

sub broadcast
{
    {
        lock %ReqSent;
        cond_broadcast %ReqSent;
    }
    {
        lock @Resps;
        cond_broadcast @Resps;
    }
}

1;

package Tests;
use strict;

use threads;
use threads::shared;
use Storable qw[freeze thaw];

my $RequestId = 0;
my %Tests :shared;
my $RunT :shared;

sub start
{
    $RunT = 1;
    Threads::start(1, \&request_checker_thread);
    Threads::start(1, \&response_checker_thread);
}

sub run
{   
    my $t = shift;

    {
        lock %Tests;
        $Tests{$RequestId} = freeze $t;
    }
    Server::set_response($t->response(), $RequestId);
    # client send queue will block until less than MAX_REQS
    Client::send_request($t->request(), $RequestId);
}

my $CheckerThreads :shared;
$CheckerThreads = 0;

sub request_checker_thread
{
    $CheckerThreads++;
    while ($RunT) {
        my ($req, $id) = Server::get_request(\$RunT)
            or next;
        my $sent = Client::get_request(\$RunT, $id)
            or next;
        check_message($sent, $req);
    }
    $CheckerThreads--;
}

sub response_checker_thread
{
    $CheckerThreads++;
    while ($RunT) {
        my ($resp, $id) = Client::get_response(\$RunT)
            or next;
        my $sent = Server::get_response(\$RunT, $id)
            or next;
        check_message($sent, $resp);
    }
    $CheckerThreads--;
}

use Time::HiRes 'usleep';

sub stop
{
    $RunT = 0;
    while ($CheckerThreads) {
        Server::broadcast();
        Client::broadcast();
    } continue {
        usleep 1;
    }
}

sub check_message
{
    my $sent = shift;
    my $got = shift;

    my $type = ref $sent eq 'HTTP::Request' ? 'request' : 'response';

    for my $name ($sent->header_field_names) {
        my $val = $got->header($name);
        if (not defined $val) {
            die "Received ${type} lacks header ${name}!\n";
        }
        my $expected = $sent->header($name);
        if ($val ne $expected) {
            die "Wrong ${type} header ${name}: ${val}, expected ${expected}\n";
        }
    }
    my $sent_content = $sent->content;
    my $got_content = $got->content;
    my $sent_len = length $sent_content;
    my $got_len = length $got_content;
    if ($sent_len != $got_len) {
        die "Wrong ${type} body size: ${got_len}, expectedd ${sent_len}\n";
    }
    if ($sent_content ne $got_content) {
        die "Wrong ${type} body content!\n";
    }
}

1;

package Test;

sub new
{
    my $class = shift;
    $class = (ref $class || $class);

    my $self = bless {
        conf => Config::get()
    } => $class;

    return $self;
}

1;

package Test::Simple;
use parent 'Test';
use strict;

use HTTP::Request::Common;
use HTTP::Response;
use HTTP::Status;

sub request
{
    my $self = shift;
    my $c = $self->{conf};
    my $url = $c->url('server_address');
    return GET($url);
}

sub response
{
    return HTTP::Response->new(
        RC_OK,
        undef,
        [
            'Content-Type' => 'text/plain',
            'Cache-Control' => 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0',
            'Pragma' => 'no-cache',
            'Expires' => 'Thu, 01 Dec 1994 16:00:00 GMT'
        ],
        "OK\n"
    );
}

1;

package main;

Server::start();
Client::start();
Tests::start();

my $t = Test::Simple->new();
Tests::run($t);

# sleep(1);
# sleep(600);

Tests::stop();
Client::stop();
Server::stop();

Threads::join();

1;
