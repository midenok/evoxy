#!/usr/bin/perl -w
package Config;
use strict;
use threads;
use threads::shared;

use Getopt::Long qw(:config bundling);
use Pod::Usage;
use Data::Dumper;

# defaults and non-CLI settings
my %CONFIG = (
    listen_ip => '127.0.0.1',
    listen_port => '8080',
    proxy_address => 'localhost:9000',
    server_threads => 1,
    client_threads => 1
);

my %OPTIONS = (
    # Format:
    # name          => ['aliases', 'type', 'description', 'dashed_variant'(generated)]
    server_address  => ['s', '=s', 'Bind HTTP server to specified IP:PORT'],
    proxy_address   => ['p', '=s', 'IP:PORT of tested HTTP proxy'],
    no_proxy        => ['P', '', "Do not use proxy. Instead send requests directly to server."],
    server_threads  => ['W', '=i', "Number of worker threads to spawn"],
    client_threads  => ['C', '=i', "Number of client threads to spawn"],
    exit_running    => ['X', '', "If can't bind HTTP server, try to stop the running one"],
    verbose         => ['v', '+', 'Verbose operation'],
    dump            => ['D', '+', 'Dump state at certain runpoint'],
);

use constant {
    ALIASES     => 0,
    TYPE        => 1,
    DESCRIPTION => 2,
    DEFAULT     => 3,
    DASHED      => 4
};

my @GETOPT_OPTS = map {
    my $specifier = $_;
    my $dashed = $_;
    my $aliases = $OPTIONS{$_}->[ALIASES];

    $specifier .= "|${dashed}"
        if $dashed =~ s/_/-/g;
    $specifier .= "|${aliases}"
        if $aliases;
    $specifier .= $OPTIONS{$_}->[TYPE];

    $OPTIONS{$_}->[DASHED] = $dashed;
    $specifier
} keys %OPTIONS;

my $singleton;

sub get
{
    return $singleton
        if $singleton;

    my $class = shift;
    $class = (ref $class || $class || __PACKAGE__);

    $singleton = bless {} => $class;
    share ($singleton);
    %$singleton = %CONFIG;

    $singleton->get_options();
    return $singleton;
}

sub require_options
{
    my $c = shift;
    my @missed = grep {
        not defined $c->{$_}
    } @_;
    if (@missed) {
        die "Required options missed: ", join(", ", map("--$_", @missed)), "\n";
    }
}

sub dump
{
    my $c = shift;
    $c->{dump} or return $c;

    my @dump;
    my %save;
    while ($_ = shift) {
        if (! ref $_ && s/^-//) {
            $save{$_} = ${$Data::Dumper::{$_}};
            ${$Data::Dumper::{$_}} = shift;
            next;
        }
        push @dump, $_;
    }

    $c->{dump}--;
    for (@dump) {
        print Dumper($_);
    }
    if (!$c->{dump}) {
        exit 0;
    }

    for (keys %save) {
        ${$Data::Dumper::{$_}} = $save{$_};
    }

    return $c;
}

sub get_options
{
    my $c = shift;
    GetOptions ($c, @GETOPT_OPTS) or exit 1;

    if ($c->{help}) {
        tie *OUT, __PACKAGE__;
        my $fh = \*OUT;
        pod2usage(-output => $fh, -verbose => 99, -sections => 'SYNOPSIS|COMMANDS|OPTIONS');
    }

    $c->process_options();
    $c->dump($c);

    return $c;
}

sub process_options
{
    my $c = shift;
    if ($c->{server_address}) {
        my @l = split(':', $c->{server_address});
        $c->{listen_ip} = $l[0] if $l[0];
        $c->{listen_port} = $l[1] if $l[1];
    } else {
        $c->{server_address} = $c->{listen_ip}. ':'. $c->{listen_port};
    }
    if ($c->{no_proxy}) {
        undef $c->{proxy_address};
    }
}

sub url
{
    my $c = shift;
    my $key = shift;
    return "http://". $c->{$key}. "/";
}

1;

package Threads;
use strict;
use threads ('yield',
             'stack_size' => 64*4096,
             'exit' => 'threads_only',
             'stringify');

my @THREADS;

sub start
{
    my $count = shift;
    for my $i (1..$count) {
        my $thr = threads->create(@_);
        push @THREADS, $thr;
    }
}

sub join
{
    for my $thr (@THREADS) {
        $thr->join();
    }
}

1;

package Server;
use strict;
use threads;
use threads::shared;
use Storable qw[freeze thaw];

use Data::Dumper;
use HTTP::Daemon;
use HTTP::Response;
use HTTP::Status;
use Errno qw[:POSIX];

my $RUN :shared;
$RUN = 1;

my %DAEMON :shared;
my $DAEMON_FD :shared;

sub start
{
    my $c = Config::get();
    my $d = HTTP::Daemon->new(
        LocalAddr => $c->{'listen_ip'},
        LocalPort => $c->{'listen_port'},
        ReuseAddr => 1
    ) or die $c->{server_address}. ": $!\n";
    
    %DAEMON = %${\*$d};
    $DAEMON_FD = fileno($d);
    open SOCK, "+<&=$DAEMON_FD" or die $!;

    Threads::start(1, \&accept_thread);
    Threads::start($c->{server_threads}, \&worker_thread);
}

sub get_daemon
{
    open SOCK, "+<&=$DAEMON_FD" or die $!;
    my $d = bless \*SOCK => 'HTTP::Daemon';
    %${\*$d} = %DAEMON;
    return $d;
}

sub get_conn
{
    my $daemon = shift;
    my $fd = shift;
    open FD, "+<&=$fd" or die $!;
    my $conn = bless \*FD => "HTTP::Daemon::ClientConn";
    %${\*$conn} = %DAEMON;
    $${\*$conn}{httpd_daemon} = $daemon;
    return $conn;
}

my @CONN :shared;
my %REQUESTS :shared;
my %RESPONSES :shared;

sub accept_thread
{
    my $d = get_daemon();
    print "Started HTTP server at " . $d->url . "\n";
    
    while ($RUN) {
        my $conn = $d->accept;
        last if $!{EINVAL};
        die "accept: $!\n" unless $conn;
        {
            my $fd = fileno($conn);
            open FD, "+<&=$fd" or die $!;
            lock @CONN;
            push @CONN, $fd;
            cond_signal @CONN;
        }
    }
}

my $WORKER_THREADS :shared;
$WORKER_THREADS = 0;

sub worker_thread
{
    {
        lock $WORKER_THREADS;
        ++$WORKER_THREADS;
    }
    my $d = get_daemon();

    loop:
    while ($RUN) {
        my $conn_fd;
        {
            lock @CONN;
            cond_wait @CONN
                until @CONN || !$RUN;
            last loop unless $RUN;
            $conn_fd = shift @CONN;
        }
        my $conn = get_conn($d, $conn_fd);

        my $req = $conn->get_request(1) or last;
        my $id = 0; #$req->id; # FIXME
        {
            lock %REQUESTS;
            $REQUESTS{$id} = freeze $req;
            cond_signal %REQUESTS;
        }
        my $resp;
        {
            lock %RESPONSES;
            cond_wait %RESPONSES
                until exists $RESPONSES{$id} || !$RUN;
            last loop unless $RUN;
            $resp = thaw $RESPONSES{$id};
            delete $RESPONSES{$id};
        }
        $conn->send_response($resp);
        $conn->close(); # FIXME: keepalives
    }
    {
        lock $WORKER_THREADS;
        --$WORKER_THREADS;
    }
}

use Time::HiRes 'usleep';

sub stop
{
    $RUN = 0;
    shutdown(get_daemon(), 2);
    while ($WORKER_THREADS) {
        {
            lock @CONN;
            cond_broadcast @CONN;
        }
        {
            lock %RESPONSES;
            cond_broadcast %RESPONSES;
        }
    } continue {
        usleep 1;
    }
}

sub get_request
{
    my $id = shift;
    my $req;
    {
        lock %REQUESTS;
        cond_wait %REQUESTS
            until exists $REQUESTS{$id};
        $req = thaw $REQUESTS{$id};
        delete $REQUESTS{$id};
    }
    return $req;       
}

sub send_response
{
    my $id = shift;
    my $resp = shift;
    lock %RESPONSES;
    $RESPONSES{$id} = freeze $resp;
    cond_signal %RESPONSES;
}

=pod
use constant HOSTNAME => qx{hostname};

@SIG{$_} = sub {
    $RUN = 0;
} for (qw[INT TERM HUP QUIT]);
=cut

1;

package Client;
use strict;
use LWP  5.825;
use threads;
use threads::shared;
use Storable qw[freeze thaw];

my @REQS :shared;
my %REQ_SENT :shared;

my %RESPS :shared;

sub start
{
    Threads::start(Config::get()->{client_threads}, \&client_thread);
}

my $CLIENT_THREADS :shared;
$CLIENT_THREADS = 0;

sub client_thread
{
    {
        lock $CLIENT_THREADS;
        ++$CLIENT_THREADS;
    }
    my $c = Config::get();
    my $ua = LWP::UserAgent->new;
    if ($c->{proxy_address}) {
        $ua->proxy('http', $c->url('proxy_address'));
    }
    
    $ua->add_handler(request_send => sub {
        my $req = $_[0];
        my $id = $req->header('X-Request-Id');
        lock %REQ_SENT;
        $REQ_SENT{$id} = freeze $req;
        cond_signal %REQ_SENT;
    });

    loop:
    while ($RUN) {
        my $req;
        {
            lock @REQS;
            cond_wait @REQS
                until @REQS || !$RUN;
            last loop unless $RUN;
            $req = thaw(shift @REQS);
        }
        my $resp = $ua->request($req);   #do it
        my $id = $resp->header('X-Request-Id');
        {
            lock %RESPS;
            $RESPS{$id} = freeze $resp;
            cond_signal %RESPS;
        }
    }
    {
        lock $CLIENT_THREADS;
        --$CLIENT_THREADS;
    }
}

use Time::HiRes 'usleep';

sub stop
{
    $RUN = 0;
    while ($CLIENT_THREADS) {
        lock @REQS;
        cond_signal @REQS;
    } continue {
        usleep 1;
    }
}

sub send_request
{
    my $req = shift;
    my $id = shift;
    $req->header('X-Request-Id' => $id);
    {
        lock @REQS;
        push @REQS, freeze $req;
        cond_signal @REQS;
    }
    my $req_sent;
    {
        lock %REQ_SENT;
        cond_wait %REQ_SENT
            until exists $REQ_SENT{$id};
        $req_sent = thaw $REQ_SENT{$id};
        delete $REQ_SENT{$id};
    }
    return $req_sent;
}

sub get_response
{
    my $id = shift;
    my $resp;
    {
        lock %RESPS;
        cond_wait %RESPS
            until exists $RESPS{$id};
        $resp = thaw $RESPS{$id};
        delete $RESPS{$id};
    }
    return $resp;
}

1;

package Tests;
use HTTP::Request::Common;

use HTTP::Response;
use HTTP::Status;

$HTTP::Request::Common::DYNAMIC_FILE_UPLOAD = 1;

my $REQ_ID = 0;

sub run
{   
    my $c = Config::get();
    my $url = $c->url('server_address');

    my $req_sent = Client::send_request(GET($url), $REQ_ID);
    my $req_got = Server::get_request($REQ_ID);
    check_message($req_sent, $req_got);
    
    my $resp = HTTP::Response->new(
        RC_OK,
        undef,
        [
            'Content-Type' => 'text/plain',
            'Cache-Control' => 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0',
            'Pragma' => 'no-cache',
            'Expires' => 'Thu, 01 Dec 1994 16:00:00 GMT',
            'X-Request-Id' => $REQ_ID
        ],
        "OK\n"
    );
    
    Server::send_response($REQ_ID, $resp);
    my $resp_got = Client::get_response($REQ_ID);
    check_message($resp, $resp_got);
}

sub check_message
{
    my $sent = shift;
    my $got = shift;
    
    my $type = ref $sent eq 'HTTP::Request' ? 'request' : 'response';

    for my $name ($sent->header_field_names) {
        my $val = $got->header($name);
        if (not defined $val) {
            die "Received ${type} lacks header ${name}!\n";
        }
        my $expected = $sent->header($name);
        if ($val ne $expected) {
            die "Wrong ${type} header ${name}: ${val}, expected ${expected}\n";
        }
    }
    my $sent_content = $sent->content;
    my $got_content = $got->content;
    my $sent_len = length $sent_content;
    my $got_len = length $got_content;
    if ($sent_len != $got_len) {
        die "Wrong ${type} body size: ${got_len}, expectedd ${sent_len}\n";
    }
    if ($sent_content ne $got_content) {
        die "Wrong ${type} body content!\n";
    }
}

1;

package main;

Server::start();
Client::start();
Tests::run();
Server::stop();
Client::stop();
Threads::join();

1;

