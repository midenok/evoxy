#!/usr/bin/perl -w
package Config;
use strict;
use threads;
use threads::shared;

use Getopt::Long qw(:config bundling);
use Pod::Usage;
use Data::Dumper;

# defaults and non-CLI settings
my %CONFIG = (
    listen_ip => '127.0.0.1',
    listen_port => '8080',
    proxy_address => 'localhost:9000',
    keep_alive => 1,
    server_threads => 1,
    client_threads => 1,
    raw_chunks_delay => 100, # usecs
    max_requests => 1,
    max_time  => 0,
    check_request => 1,
    check_response => 1
);

my %TESTS = (
    simple => 'Simple GET',
    raw => 'Raw GET sent by small portions'
);

my %OPTIONS = (
    # Format:
    # name          => ['aliases', 'type', 'description', 'dashed_variant'(generated)]
    server_address  => ['s', '=s', 'Bind HTTP server to specified IP:PORT'],
    proxy_address   => ['p', '=s', 'IP:PORT of tested HTTP proxy'],
    no_proxy        => ['P', '', "Do not use proxy, instead send requests directly to server."],
    keep_alive      => ['k', '!', "Use persistent connections"],
    server_threads  => ['W', '=i', "Number of worker threads to spawn"],
    client_threads  => ['C', '=i', "Number of client threads to spawn"],
    max_requests    => ['n', '=i', "Number of requests to send"],
    max_time        => ['t', '=i', "Maximum time in seconds to run tests"],
    check_request   => ['chreq', '!', "Compare requests sent by client and received by server"],
    check_response  => ['chresp', '!', "Compare responses sent by server and received by client"],
    no_check        => ['nochk', '', "Same as: --no-check-request --no-check-response"],
    exit_running    => ['X', '', "If can't bind HTTP server, try to stop the running one"],
    verbose         => ['v', '+', 'Verbose operation'],
    dump            => ['D', '+', 'Dump state at certain runpoint'],
);

use constant {
    ALIASES     => 0,
    TYPE        => 1,
    DESCRIPTION => 2,
    DEFAULT     => 3,
    DASHED      => 4
};

my @GETOPT_OPTS = map {
    my $specifier = $_;
    my $dashed = $_;
    my $aliases = $OPTIONS{$_}->[ALIASES];

    $specifier .= "|${dashed}"
        if $dashed =~ s/_/-/g;
    $specifier .= "|${aliases}"
        if $aliases;
    $specifier .= $OPTIONS{$_}->[TYPE];

    $OPTIONS{$_}->[DASHED] = $dashed;
    $specifier
} keys %OPTIONS;

my $singleton;

sub get
{
    return $singleton
        if $singleton;

    my $class = shift;
    $class = (ref $class || $class || __PACKAGE__);

    $singleton = bless {} => $class;
    share ($singleton);
    %$singleton = %CONFIG;

    $singleton->get_options();
    return $singleton;
}

sub require_options
{
    my $c = shift;
    my @missed = grep {
        not defined $c->{$_}
    } @_;
    if (@missed) {
        die "Required options missed: ", join(", ", map("--$_", @missed)), "\n";
    }
}

sub dump
{
    my $c = shift;
    $c->{dump} or return $c;

    my @dump;
    my %save;
    while ($_ = shift) {
        if (! ref $_ && s/^-//) {
            $save{$_} = ${$Data::Dumper::{$_}};
            ${$Data::Dumper::{$_}} = shift;
            next;
        }
        push @dump, $_;
    }

    $c->{dump}--;
    for (@dump) {
        print Dumper($_);
    }
    if (!$c->{dump}) {
        exit 0;
    }

    for (keys %save) {
        ${$Data::Dumper::{$_}} = $save{$_};
    }

    return $c;
}

sub get_options
{
    my $c = shift;
    GetOptions ($c, @GETOPT_OPTS) or exit 1;

    if ($c->{help}) {
        tie *OUT, __PACKAGE__;
        my $fh = \*OUT;
        pod2usage(-output => $fh, -verbose => 99, -sections => 'SYNOPSIS|COMMANDS|OPTIONS');
    }

    $c->process_options();
    $c->dump($c);

    return $c;
}

sub process_options
{
    my $c = shift;
    if ($c->{server_address}) {
        my @l = split(':', $c->{server_address});
        $c->{listen_ip} = $l[0] if $l[0];
        $c->{listen_port} = $l[1] if $l[1];
    } else {
        $c->{server_address} = $c->{listen_ip}. ':'. $c->{listen_port};
    }
    $c->{server_url} = "http://". $c->{server_address}. "/";

    if ($c->{no_proxy}) {
        undef $c->{proxy_address};
    } else {
        $c->{proxy_url} = "http://". $c->{proxy_address}. "/";
    }
    if ($c->{no_check}) {
        $c->{check_request} = 0;
        $c->{check_response} = 0;
    }
}

sub run_condition
{
    my $c = shift;
    my $requests = shift;
    my $watch = shift;

    if ($c->{max_requests} && $requests >= $c->{max_requests}) {
        return 0;
    }
    if ($c->{max_time} && $watch->run_time > $c->{max_time}) {
        $c->{time_up} = 1;
        return 0;
    }
    return 1;
}

1;

package Threads;
use strict;
use threads qw[stringify];

use Carp;

my @Threads;

sub start
{
    my $count = shift;
    for my $i (1..$count) {
        my $thr = threads->create(@_);
        push @Threads, $thr;
    }
}

sub join
{
    for my $thr (@Threads) {
        $thr->join();
    }
}

sub die
{
    # carp @_;
    # threads->exit() if threads->can('exit');   # Thread friendly
    # TODO: clean die
    exit 1;
}

1;

package Server;
use strict;
use threads;
use threads::shared;
use Storable qw[freeze thaw];

use HTTP::Daemon;
use HTTP::Response;
use HTTP::Status;
use Errno qw[:POSIX];

my $RunS :shared;
my %Daemon :shared;
my $DaemonFD :shared;

sub start
{
    my $c = Config::get();
    my $d = HTTP::Daemon->new(
        LocalAddr => $c->{'listen_ip'},
        LocalPort => $c->{'listen_port'},
        ReuseAddr => 1
    ) or die $c->{server_address}. ": $!\n";
    print "Started HTTP server at " . $d->url . "\n";

    %Daemon = %${\*$d};
    $DaemonFD = fileno($d);
    open my $fh, "+<&=$DaemonFD" or die $!;

    $RunS = 1;
    Threads::start($c->{server_threads}, \&worker_thread);
}

sub get_daemon
{
    open my $fh, "+<&=$DaemonFD" or Threads::die "$!";
    my $d = bless $fh => 'HTTP::Daemon';
    %${\*$d} = %Daemon;
    return $d;
}

my @Requests :shared;
my %Responses :shared;
my %ResponsesSent :shared;

my $WorkerThreads :shared;
$WorkerThreads = 0;

sub worker_thread
{
    {lock $WorkerThreads;
    ++$WorkerThreads;}
    my $d = get_daemon();
    my $c = Config::get();

    loop:
    while ($RunS) {
        my $conn = $d->accept;
        last loop if $!{EINVAL};
        Threads::die "accept: $!\n" unless $conn;

        $conn->autoflush(1);
        while (1) {
            my $req = $conn->get_request(1)
                or next loop; # FIXME: check errno
            my $id = $req->header('X-Request-Id');
            my $req_frozen = freeze [$req, $id];
            {
                lock @Requests;
                push @Requests, $req_frozen;
                cond_signal @Requests;
            }
    
            my $test;
            {
                lock %Responses;
                cond_wait %Responses
                    until exists $Responses{$id} || !$RunS;
                last loop unless $RunS;
                $test = $Responses{$id};
                delete $Responses{$id};
            }
            $test = thaw $test;
            my ($ok, $resp) = $test->send_response($id, $conn);
            Threads::die "$!" unless $ok;
            $resp = freeze $resp;
            if ($c->{check_response}) {
                lock %ResponsesSent;
                $ResponsesSent{$id} = $resp;
                cond_signal %ResponsesSent;
            }
            if ($${\*$conn}{httpd_nomore}) {
                shutdown($conn, 2);
                last;
            }
        }
    }
    {lock $WorkerThreads;
    --$WorkerThreads;}
}

use Time::HiRes 'usleep';

sub stop
{
    $RunS = 0;
    shutdown(get_daemon(), 2);
    while ($WorkerThreads) {
        lock %Responses;
        cond_broadcast %Responses;
    } continue {
        usleep 1;
    }
}

sub get_request
{
    my $run = shift;
    my $req;
    my $id;
    my $frozen;
    {
        lock @Requests;
        cond_wait @Requests
            until @Requests || !$$run;
        return unless $$run;
        $frozen = shift @Requests;
    }
    ($req, $id) = @{thaw $frozen};
    return ($req, $id);
}

sub get_response
{
    my $run = shift;
    my $id = shift;
    my $resp;
    {
        lock %ResponsesSent;
        cond_wait %ResponsesSent
            until exists $ResponsesSent{$id} || !$$run;
        return unless $$run;
        $resp = $ResponsesSent{$id};
        delete $ResponsesSent{$id};
    }
    $resp = thaw $resp;
    return $resp;
}

sub broadcast
{
    {
        lock @Requests;
        cond_broadcast @Requests;
    }
    {
        lock %ResponsesSent;
        cond_broadcast %ResponsesSent;
    }
}

sub set_response
{
    my $test = shift;
    my $id = shift;
    $test = freeze $test if ref $test;
    {
        lock %Responses;
        $Responses{$id} = $test;
        cond_signal %Responses;
    }
    return $test;
}

=pod
@SIG{$_} = sub {
    $RUN = 0;
} for (qw[INT TERM HUP QUIT]);
=cut

1;

package Client;
use strict;
use LWP  5.825;
use Time::HiRes 'usleep';

use threads;
use threads::shared;
use Storable qw[freeze thaw];

my $RunC :shared;

use constant MAX_REQS => 1000;
my @CQueue :shared;
my $CQFreed :shared;
my %ReqSent :shared;

my @Resps :shared;

sub start
{
    $RunC = 1;
    Threads::start(Config::get()->{client_threads}, \&client_thread);
}

my $ClientThreads :shared;
$ClientThreads = 0;

sub push_req_sent
{
    my $req = $_[0];
    my $id = $req->header('X-Request-Id');
    my $frozen = freeze $req;
    lock %ReqSent;
    $ReqSent{$id} = $frozen;
    cond_signal %ReqSent;
}

sub client_thread
{
    {lock $ClientThreads;
    ++$ClientThreads;}
    my $c = Config::get();
    my $ua = LWP::UserAgent->new(keep_alive => $c->{keep_alive});
    if ($c->{proxy_address}) {
        $ua->proxy('http', $c->{'proxy_url'});
    }

    if ($c->{check_request}) {
        $ua->add_handler(request_send => \&push_req_sent);
    }

    loop:
    while ($RunC) {
        my $frozen;
        {
            lock @CQueue;
            cond_wait @CQueue
                until @CQueue || !$RunC;
            last loop unless $RunC;
            $frozen = shift @CQueue;
            if (@CQueue == MAX_REQS - 1) {
                lock $CQFreed;
                cond_signal $CQFreed;
            }
        }

        my ($test, $id) = @{thaw $frozen};
        my $resp = $test->send_request($id, $ua);
 
        Threads::die "$!" if $!;
        $frozen = freeze [ $resp, $id ];
        {
            lock @Resps;
            push @Resps, $frozen;
            cond_signal @Resps;
        }
    }
    {lock $ClientThreads;
    --$ClientThreads;}
}

sub stop
{
    $RunC = 0;
    while ($ClientThreads) {
        lock @CQueue;
        cond_signal @CQueue;
    } continue {
        usleep 1;
    }
}

sub enqueue_request
{
    my $frozen = freeze [$_[0], $_[1]];
    {
        lock @CQueue;
        cond_wait $CQFreed, @CQueue
            until @CQueue < MAX_REQS;
        push @CQueue, $frozen;
        cond_signal @CQueue;
    }
    return $frozen;
}

sub clear_queue
{
    my @id;
    lock @CQueue;
    @id = map { thaw ($_)->[1] } @CQueue;
    @CQueue = ();
    return \@id;
}

sub get_request
{
    my $run = shift;
    my $id = shift;
    my $req_sent;
    {
        lock %ReqSent;
        until (exists $ReqSent{$id} || !$$run) {
            cond_wait %ReqSent;
        }
        return unless $$run;
        $req_sent = $ReqSent{$id};
        delete $ReqSent{$id};
    }
    $req_sent = thaw $req_sent;
    return $req_sent;
}

sub get_response
{
    my $run = shift;
    my $resp;
    my $id;
    my $frozen;
    {
        lock @Resps;
        until (@Resps || !$$run) {
            cond_wait @Resps;
        }
        return unless $$run;
        $frozen = shift @Resps;
    }
    ($resp, $id) = @{thaw $frozen};
    return ($resp, $id);
}

sub broadcast
{
    {
        lock %ReqSent;
        cond_broadcast %ReqSent;
    }
    {
        lock @Resps;
        cond_broadcast @Resps;
    }
}

1;

package Stopwatch;
use Time::HiRes qw[gettimeofday tv_interval];

sub new
{
    my $class = shift;
    $class = (ref $class || $class);

    my $self = bless {
        start_time => shift,
        stop_time => undef,
        elapsed => undef
    } => $class;

    return $self;
}

sub start
{
    my $self = shift;
    $self->{start_time} = [gettimeofday];
}

sub start_time
{
    my $self = shift;
    return ref $self->{start_time} eq __PACKAGE__ ?
        $self->{start_time}->start_time() :
        $self->{start_time};
}

sub stop
{
    my $self = shift;
    $self->{stop_time} = [gettimeofday];
    $self->{elapsed} = tv_interval($self->start_time, $self->{stop_time});
}

sub print
{
    my $self = shift;
    my $reqs = shift;
    my $elpsd = $self->{elapsed};
    my $reqs_per_sec = $reqs / $elpsd;
    {
        use integer;
        $reqs_per_sec /= 1;
    }
    print "Finished in $elpsd secs\n", "$reqs_per_sec requests/sec\n";
}

sub run_time
{
    my $self = shift;
    return wantarray ?
        tv_interval($self->start_time, [gettimeofday]) :
        time - $self->start_time->[0];
}

1;

package Tests;
use strict;

use HTTP::Status;

use threads;
use threads::shared;
use Storable qw[freeze thaw];

my $ReqId = 0;
my $ReqDone :shared;
$ReqDone = 0;
my %Tests :shared;
my $RunT :shared;

my $Watch = Stopwatch->new();

sub start
{
    $RunT = 1;
    my $c = Config::get();
    if ($c->{check_request}) {
        Threads::start(1, \&request_checker_thread);
    }
    Threads::start(1, \&response_checker_thread);
}

sub run
{   
    my $test = shift;
    my $frozen_test = freeze $test;
    my $c = Config::get();

    $Watch->start;

    for (my $n = 0; $c->run_condition($n, $Watch); ++$n) {
        {lock %Tests;
        $Tests{$ReqId} = $frozen_test;}
        Server::set_response($frozen_test, $ReqId);
        # client send queue will block until less than MAX_REQS
        Client::enqueue_request($test, $ReqId);
        $ReqId++;
    }
    if ($c->{time_up}) {
        my $cleared = Client::clear_queue();
        lock %Tests;
        for my $id (@$cleared) {
            delete $Tests{$id};
        }
        cond_signal %Tests;
    }
}

sub wait
{
    lock %Tests;
    cond_wait %Tests
        while %Tests;

    $Watch->stop;
    $Watch->print($ReqDone);
}

my $CheckerThreads :shared;
$CheckerThreads = 0;

sub request_checker_thread
{
    {lock $CheckerThreads;
    $CheckerThreads++;}
    while ($RunT) {
        my ($req, $id) = Server::get_request(\$RunT)
            or next;
        my $sent = Client::get_request(\$RunT, $id)
            or next;
        check_message($sent, $req);
    }
    {lock $CheckerThreads;
    $CheckerThreads--;}
}

sub response_checker_thread
{
    {lock $CheckerThreads;
    $CheckerThreads++;}

    my $c = Config::get();

    while ($RunT) {
        my ($resp, $id) = Client::get_response(\$RunT)
            or next;

        if ($c->{check_response}) {
            my $sent = Server::get_response(\$RunT, $id)
                or next;
            check_message($sent, $resp);
        }
        {
            lock %Tests;
            delete $Tests{$id};
            cond_signal %Tests;
        }
        ++$ReqDone;
    }
    {lock $CheckerThreads;
    $CheckerThreads--;}
}

use Time::HiRes 'usleep';

sub stop
{
    $RunT = 0;
    while ($CheckerThreads) {
        Server::broadcast();
        Client::broadcast();
    } continue {
        usleep 1;
    }
}

sub check_message
{
    my $sent = shift;
    my $got = shift;

    my $type = ref $sent eq 'HTTP::Request' ? 'request' : 'response';

    for my $name ($sent->header_field_names) {
        my $val = $got->header($name);
        if (not defined $val) {
            Threads::die "Received ${type} lacks header ${name}!\n";
        }
        my $expected = $sent->header($name);
        $expected =~ s/[\r\n\t ]+/ /gm; # multi-line headers are catenated in HTTP::Daemon
        if ($val ne $expected) {
            Threads::die "Wrong ${type} header ${name}: ${val}, expected ${expected}\n";
        }
    }
    my $sent_content = $sent->content;
    my $got_content = $got->content;
    my $sent_len = length $sent_content;
    my $got_len = length $got_content;
    if ($sent_len != $got_len) {
        Threads::die "Wrong ${type} body size: ${got_len}, expectedd ${sent_len}\n";
    }
    if ($sent_content ne $got_content) {
        Threads::die "Wrong ${type} body content!\n";
    }
}

1;

package Test::Simple;
use strict;

use HTTP::Request::Common;
use HTTP::Response;
use HTTP::Status;

sub new
{
    my $class = shift;
    $class = (ref $class || $class);

    my $self = bless {} => $class;

    return $self;
}

sub send_request
{
    my $self = shift;
    my $id = shift;
    my $ua = shift;
    my $req = $self->build_request($id);
    return $ua->request($req);
}

sub send_response
{
    my $self = shift;
    my $id = shift;
    my $conn = shift;
    my $resp = $self->build_response($id);
    return ($conn->send_response($resp), $resp);
}

sub build_request
{
    my $self = shift;
    my $id = shift;
    my $c = Config::get();
    my $req = GET($c->{server_url});
    $req->header('X-Request-Id' => $id);
    return $req;
}

sub build_response
{
    my $self = shift;
    my $request_id = shift;

    return HTTP::Response->new(
        RC_OK,
        undef,
        [
            'X-Request-Id' => $request_id,
            'Content-Type' => 'text/plain',
            'Cache-Control' => 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0',
            'Pragma' => 'no-cache',
            'Expires' => 'Thu, 01 Dec 1994 16:00:00 GMT'
        ],
        "OK\n"
    );
}

1;

package Test::Raw;
use parent 'Test::Simple';
use strict;

use HTTP::Request;
use HTTP::Response;
use Socket qw[:all];
use Time::HiRes qw[usleep];

sub send_request
{
    my $self = shift;
    my $id = shift;

    my $c = Config::get();
    my $req_raw = $self->build_request($id);
    my @chunks = split('~~~', $req_raw);
    my $req = HTTP::Request->parse(join('', @chunks));

    if ($c->{check_request}) {
        push_req_sent($req);
    }

    my $host = $req->header('Host');
    my $sock = IO::Socket::INET->new(
        PeerAddr => $req->header('Host'),
        Proto => 'tcp'
    ) or Threads::die "connect: $!";
    setsockopt($sock, IPPROTO_TCP, TCP_NODELAY, 1);
    for my $chunk (@chunks) {
        $sock->send($chunk);
        usleep $c->{raw_chunks_delay};
    }
    my $resp_raw;
    my $buf;
    do {
        defined $sock->recv($buf, 4096) # TODO: locks on Keep-Alive
            or Threads::die "recv: $!";
        $resp_raw .= $buf;
    } while (length($buf));
    my $resp = HTTP::Response->parse($resp_raw);
    return $resp;
}

sub build_request
{
    my $self = shift;
    my $request_id = shift;
    my $c = Config::get();
    my $req =<<EOF;
GET / HTTP/1.1\r
User-Agent: Wget/1.17.1 (cygwin)\r
Accept: */*\r
Host: $c->{server_address}\r
X-Request-Id: ${request_id}\r
X-Multi-Line-Header: line 1\r
 line 2\r
   \t \t   \t line 3\r
 line 4\r
Accept-Encoding: identity\r
Connection: Close\r
~~~\r
EOF
    return $req;
}

1;

package main;

Server::start();
Client::start();
Tests::start();

my $t = Test::Simple->new();
Tests::run($t);
Tests::wait();

Tests::stop();
Client::stop();
Server::stop();

Threads::join();

1;
