#!/usr/bin/perl -w
package Config;
use strict;
use threads;
use threads::shared;

use Getopt::Long qw(:config bundling);
use Pod::Usage;
use Data::Dumper;

# defaults and non-CLI settings
my %CONFIG = (
    listen_ip => '127.0.0.1',
    listen_port => '8080',
    proxy_address => 'localhost:9000',
    server_threads => 1,
    client_threads => 1,
    raw_chunks_delay => 100 # usecs
);

my %OPTIONS = (
    # Format:
    # name          => ['aliases', 'type', 'description', 'dashed_variant'(generated)]
    server_address  => ['s', '=s', 'Bind HTTP server to specified IP:PORT'],
    proxy_address   => ['p', '=s', 'IP:PORT of tested HTTP proxy'],
    no_proxy        => ['P', '', "Do not use proxy. Instead send requests directly to server."],
    server_threads  => ['W', '=i', "Number of worker threads to spawn"],
    client_threads  => ['C', '=i', "Number of client threads to spawn"],
    exit_running    => ['X', '', "If can't bind HTTP server, try to stop the running one"],
    verbose         => ['v', '+', 'Verbose operation'],
    dump            => ['D', '+', 'Dump state at certain runpoint'],
);

use constant {
    ALIASES     => 0,
    TYPE        => 1,
    DESCRIPTION => 2,
    DEFAULT     => 3,
    DASHED      => 4
};

my @GETOPT_OPTS = map {
    my $specifier = $_;
    my $dashed = $_;
    my $aliases = $OPTIONS{$_}->[ALIASES];

    $specifier .= "|${dashed}"
        if $dashed =~ s/_/-/g;
    $specifier .= "|${aliases}"
        if $aliases;
    $specifier .= $OPTIONS{$_}->[TYPE];

    $OPTIONS{$_}->[DASHED] = $dashed;
    $specifier
} keys %OPTIONS;

my $singleton;

sub get
{
    return $singleton
        if $singleton;

    my $class = shift;
    $class = (ref $class || $class || __PACKAGE__);

    $singleton = bless {} => $class;
    share ($singleton);
    %$singleton = %CONFIG;

    $singleton->get_options();
    return $singleton;
}

sub require_options
{
    my $c = shift;
    my @missed = grep {
        not defined $c->{$_}
    } @_;
    if (@missed) {
        die "Required options missed: ", join(", ", map("--$_", @missed)), "\n";
    }
}

sub dump
{
    my $c = shift;
    $c->{dump} or return $c;

    my @dump;
    my %save;
    while ($_ = shift) {
        if (! ref $_ && s/^-//) {
            $save{$_} = ${$Data::Dumper::{$_}};
            ${$Data::Dumper::{$_}} = shift;
            next;
        }
        push @dump, $_;
    }

    $c->{dump}--;
    for (@dump) {
        print Dumper($_);
    }
    if (!$c->{dump}) {
        exit 0;
    }

    for (keys %save) {
        ${$Data::Dumper::{$_}} = $save{$_};
    }

    return $c;
}

sub get_options
{
    my $c = shift;
    GetOptions ($c, @GETOPT_OPTS) or exit 1;

    if ($c->{help}) {
        tie *OUT, __PACKAGE__;
        my $fh = \*OUT;
        pod2usage(-output => $fh, -verbose => 99, -sections => 'SYNOPSIS|COMMANDS|OPTIONS');
    }

    $c->process_options();
    $c->dump($c);

    return $c;
}

sub process_options
{
    my $c = shift;
    if ($c->{server_address}) {
        my @l = split(':', $c->{server_address});
        $c->{listen_ip} = $l[0] if $l[0];
        $c->{listen_port} = $l[1] if $l[1];
    } else {
        $c->{server_address} = $c->{listen_ip}. ':'. $c->{listen_port};
    }
    if ($c->{no_proxy}) {
        undef $c->{proxy_address};
    }
}

sub url
{
    my $c = shift;
    my $key = shift;
    return "http://". $c->{$key}. "/";
}

1;

package Threads;
use strict;
use threads ('yield',
             'stack_size' => 64*4096,
             'exit' => 'threads_only',
             'stringify');

my @Threads;

sub start
{
    my $count = shift;
    for my $i (1..$count) {
        my $thr = threads->create(@_);
        push @Threads, $thr;
    }
}

sub join
{
    for my $thr (@Threads) {
        $thr->join();
    }
}

1;

package Server;
use strict;
use threads;
use threads::shared;
use Storable qw[freeze thaw];

use HTTP::Daemon;
use HTTP::Response;
use HTTP::Status;
use Errno qw[:POSIX];

my $RunS :shared;
my %Daemon :shared;
my $DaemonFD :shared;

sub start
{
    my $c = Config::get();
    my $d = HTTP::Daemon->new(
        LocalAddr => $c->{'listen_ip'},
        LocalPort => $c->{'listen_port'},
        ReuseAddr => 1
    ) or die $c->{server_address}. ": $!\n";
    print "Started HTTP server at " . $d->url . "\n";

    %Daemon = %${\*$d};
    $DaemonFD = fileno($d);
    open my $fh, "+<&=$DaemonFD" or die $!;

    $RunS = 1;
    Threads::start($c->{server_threads}, \&worker_thread);
}

sub get_daemon
{
    open my $fh, "+<&=$DaemonFD" or die $!;
    my $d = bless $fh => 'HTTP::Daemon';
    %${\*$d} = %Daemon;
    return $d;
}

my @Requests :shared;
my %Responses :shared;
my %ResponsesSent :shared;

my $WorkerThreads :shared;
$WorkerThreads = 0;

sub worker_thread
{
    {lock $WorkerThreads;
    ++$WorkerThreads;}
    my $d = get_daemon();

    loop:
    while ($RunS) {
        my $conn = $d->accept;
        last loop if $!{EINVAL};
        die "accept: $!\n" unless $conn;

        $conn->autoflush(1);
        my $req = $conn->get_request(1) or last;
        my $id = $req->header('X-Request-Id');
        {
            lock @Requests;
            push @Requests, freeze [$req, $id];
            cond_signal @Requests;
        }
        my $resp;
        my $resp_frozen;
        {
            lock %Responses;
            cond_wait %Responses
                until exists $Responses{$id} || !$RunS;
            last loop unless $RunS;
            $resp_frozen = $Responses{$id};
            delete $Responses{$id};
        }
        $resp = thaw $resp_frozen;
        $conn->send_response($resp);
        {
            lock %ResponsesSent;
            $ResponsesSent{$id} = $resp_frozen;
            cond_signal %ResponsesSent;
        }
        shutdown($conn, 2); # FIXME: keepalives
    }
    {lock $WorkerThreads;
    --$WorkerThreads;}
    print "Exiting $WorkerThreads\n";
}

use Time::HiRes 'usleep';

sub stop
{
    $RunS = 0;
    shutdown(get_daemon(), 2);
    while ($WorkerThreads) {
        lock %Responses;
        cond_broadcast %Responses;
    } continue {
        usleep 1;
    }
}

sub get_request
{
    my $run = shift;
    my $req;
    my $id;
    {
        lock @Requests;
        cond_wait @Requests
            until @Requests || !$$run;
        return unless $$run;
        ($req, $id) = @{thaw shift @Requests};
    }
    return ($req, $id);
}

sub get_response
{
    my $run = shift;
    my $id = shift;
    my $resp;
    {
        lock %ResponsesSent;
        cond_wait %ResponsesSent
            until exists $ResponsesSent{$id} || !$$run;
        return unless $$run;
        $resp = thaw $ResponsesSent{$id};
        delete $ResponsesSent{$id};
    }
    return $resp;
}

sub broadcast
{
    {
        lock @Requests;
        cond_broadcast @Requests;
    }
    {
        lock %ResponsesSent;
        cond_broadcast %ResponsesSent;
    }
}

sub set_response
{
    my $resp = shift;
    my $id = shift;
    {
        lock %Responses;
        $Responses{$id} = freeze $resp;
        cond_signal %Responses;
    }
    return $resp;
}

=pod
@SIG{$_} = sub {
    $RUN = 0;
} for (qw[INT TERM HUP QUIT]);
=cut

1;

package Client;
use strict;
use LWP  5.825;
use Socket qw(:all);
use Time::HiRes 'usleep';

use threads;
use threads::shared;
use Storable qw[freeze thaw];

my $RunC :shared;

use constant MAX_REQS => 1000;
my @Reqs :shared;
my $ReqsFreed :shared;
my %ReqSent :shared;

my @Resps :shared;

sub start
{
    $RunC = 1;
    Threads::start(Config::get()->{client_threads}, \&client_thread);
}

my $ClientThreads :shared;
$ClientThreads = 0;

sub push_req_sent
{
    my $req = $_[0];
    my $id = $req->header('X-Request-Id');
    lock %ReqSent;
    $ReqSent{$id} = freeze $req;
    cond_signal %ReqSent;
}

sub client_thread
{
    {lock $ClientThreads;
    ++$ClientThreads;}
    my $c = Config::get();
    my $ua = LWP::UserAgent->new;
    if ($c->{proxy_address}) {
        $ua->proxy('http', $c->url('proxy_address'));
    }

    $ua->add_handler(request_send => \&push_req_sent);

    loop:
    while ($RunC) {
        my $req;
        {
            lock @Reqs;
            cond_wait @Reqs
                until @Reqs || !$RunC;
            last loop unless $RunC;
            $req = shift @Reqs;
            if (@Reqs == MAX_REQS - 1) {
                lock $ReqsFreed;
                cond_signal $ReqsFreed;
            }
        }

        eval { $req = thaw $req; };
        my $resp;
        if (ref $req) {
            $resp = $ua->request($req);
        } else {
            $resp = raw_request($req);
        }
        my $id = $resp->header('X-Request-Id');
        {
            lock @Resps;
            push @Resps, freeze [ $resp, $id ];
            cond_signal @Resps;
        }
    }
    {lock $ClientThreads;
    --$ClientThreads;}
}

sub raw_request
{
    my $c = Config::get();
    my $req_raw = shift;
    my @chunks = split('~~~', $req_raw);
    my $req = HTTP::Request->parse(join('', @chunks));
    push_req_sent($req);
    my $host = $req->header('Host');
    my $sock = IO::Socket::INET->new(
        PeerAddr => $req->header('Host'),
        Proto => 'tcp'
    ) or die "connect: $!";
    setsockopt($sock, IPPROTO_TCP, TCP_NODELAY, 1);
    for my $chunk (@chunks) {
        $sock->send($chunk);
        usleep $c->{raw_chunks_delay};
    }
    my $resp_raw;
    my $buf;
    do {
        defined $sock->recv($buf, 4096) # TODO: locks on Keep-Alive
            or die "recv: $!";
        $resp_raw .= $buf;
    } while (length($buf));
    my $resp = HTTP::Response->parse($resp_raw);
    return $resp;
}

sub stop
{
    $RunC = 0;
    while ($ClientThreads) {
        lock @Reqs;
        cond_signal @Reqs;
    } continue {
        usleep 1;
    }
}

sub send_request
{
    my $req = shift;
    if (ref $req) {
        $req = freeze $req;
    }
    {
        lock @Reqs;
        cond_wait $ReqsFreed, @Reqs
            until @Reqs < MAX_REQS;
        push @Reqs, $req;
        cond_signal @Reqs;
    }
}

sub get_request
{
    my $run = shift;
    my $id = shift;
    my $req_sent;
    {
        lock %ReqSent;
        until (exists $ReqSent{$id} || !$$run) {
            cond_wait %ReqSent;
        }
        return unless $$run;
        $req_sent = thaw $ReqSent{$id};
        delete $ReqSent{$id};
    }
    return $req_sent;
}

sub get_response
{
    my $run = shift;
    my $resp;
    my $id;
    {
        lock @Resps;
        until (@Resps || !$$run) {
            cond_wait @Resps;
        }
        return unless $$run;
        ($resp, $id) = @{thaw shift @Resps};
    }
    return ($resp, $id);
}

sub broadcast
{
    {
        lock %ReqSent;
        cond_broadcast %ReqSent;
    }
    {
        lock @Resps;
        cond_broadcast @Resps;
    }
}

1;

package Stopwatch;
use Time::HiRes qw[gettimeofday tv_interval];

sub new
{
    my $class = shift;
    $class = (ref $class || $class);

    my $self = bless {
        start_time => shift,
        stop_time => undef,
        elapsed => undef
    } => $class;

    return $self;
}

sub start
{
    my $self = shift;
    $self->{start_time} = [gettimeofday];
}

sub start_time
{
    my $self = shift;
    return ref $self->{start_time} eq __PACKAGE__ ?
        $self->{start_time}->start_time() :
        $self->{start_time};
}

sub stop
{
    my $self = shift;
    $self->{stop_time} = [gettimeofday];
    $self->{elapsed} = tv_interval($self->start_time, $self->{stop_time});
}

sub print
{
    my $self = shift;
    my $reqs = shift;
    my $elpsd = $self->{elapsed};
    my $reqs_per_sec = $reqs / $elpsd;
    {
        use integer;
        $reqs_per_sec /= 1;
    }
    print "Finished in $elpsd secs\n", "$reqs_per_sec requests/sec\n";
}

1;

package Tests;
use strict;

use threads;
use threads::shared;
use Storable qw[freeze thaw];

my $ReqId = 0;
my $ReqDone :shared;
$ReqDone = 0;
my %Tests :shared;
my $RunT :shared;

my $Watch = Stopwatch->new();

sub start
{
    $RunT = 1;
    Threads::start(1, \&request_checker_thread);
    Threads::start(1, \&response_checker_thread);
}

sub run
{   
    my $t = shift;

    $Watch->start;

    for (my $n = 0; $n < 500; ++$n) {
        {
            lock %Tests;
            $Tests{$ReqId} = freeze $t;
        }
        Server::set_response($t->response($ReqId), $ReqId);
        # client send queue will block until less than MAX_REQS
        Client::send_request($t->request($ReqId));
        $ReqId++;
    }
}

sub wait
{
    lock %Tests;
    cond_wait %Tests
        while %Tests;

    $Watch->stop;
    $Watch->print($ReqDone);
}

my $CheckerThreads :shared;
$CheckerThreads = 0;

sub request_checker_thread
{
    {lock $CheckerThreads;
    $CheckerThreads++;}
    while ($RunT) {
        my ($req, $id) = Server::get_request(\$RunT)
            or next;
        my $sent = Client::get_request(\$RunT, $id)
            or next;
        check_message($sent, $req);
    }
    {lock $CheckerThreads;
    $CheckerThreads--;}
}

sub response_checker_thread
{
    {lock $CheckerThreads;
    $CheckerThreads++;}
    while ($RunT) {
        my ($resp, $id) = Client::get_response(\$RunT)
            or next;
        my $sent = Server::get_response(\$RunT, $id)
            or next;
        check_message($sent, $resp);
        {
            lock %Tests;
            delete $Tests{$id};
            cond_signal %Tests;
        }
        ++$ReqDone;
    }
    {lock $CheckerThreads;
    $CheckerThreads--;}
}

use Time::HiRes 'usleep';

sub stop
{
    $RunT = 0;
    while ($CheckerThreads) {
        Server::broadcast();
        Client::broadcast();
    } continue {
        usleep 1;
    }
}

sub check_message
{
    my $sent = shift;
    my $got = shift;

    my $type = ref $sent eq 'HTTP::Request' ? 'request' : 'response';

    for my $name ($sent->header_field_names) {
        my $val = $got->header($name);
        if (not defined $val) {
            die "Received ${type} lacks header ${name}!\n";
        }
        my $expected = $sent->header($name);
        $expected =~ s/[\r\n\t ]+/ /gm; # multi-line headers are catenated in HTTP::Daemon
        if ($val ne $expected) {
            die "Wrong ${type} header ${name}: ${val}, expected ${expected}\n";
        }
    }
    my $sent_content = $sent->content;
    my $got_content = $got->content;
    my $sent_len = length $sent_content;
    my $got_len = length $got_content;
    if ($sent_len != $got_len) {
        die "Wrong ${type} body size: ${got_len}, expectedd ${sent_len}\n";
    }
    if ($sent_content ne $got_content) {
        die "Wrong ${type} body content!\n";
    }
}

1;

package Test;
use HTTP::Response;
use HTTP::Status;

sub new
{
    my $class = shift;
    $class = (ref $class || $class);

    my $self = bless {
        conf => Config::get()
    } => $class;

    return $self;
}

sub response
{
    my $self = shift;
    my $request_id = shift;

    return HTTP::Response->new(
        RC_OK,
        undef,
        [
            'X-Request-Id' => $request_id,
            'Content-Type' => 'text/plain',
            'Cache-Control' => 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0',
            'Pragma' => 'no-cache',
            'Expires' => 'Thu, 01 Dec 1994 16:00:00 GMT'
        ],
        "OK\n"
    );
}

1;

package Test::Simple;
use parent 'Test';
use strict;

use HTTP::Request::Common;

sub request
{
    my $self = shift;
    my $id = shift;
    my $c = $self->{conf};
    my $req = GET($c->url('server_address'));
    $req->header('X-Request-Id' => $id);
    return $req;
}

1;

package Test::Raw;
use parent 'Test';
use strict;

sub request
{
    my $self = shift;
    my $request_id = shift;
    my $c = $self->{conf};
    my $req =<<EOF;
GET / HTTP/1.1\r
User-Agent: Wget/1.17.1 (cygwin)\r
Accept: */*\r
Host: $c->{server_address}\r
X-Request-Id: ${request_id}\r
X-Multi-Line-Header: line 1\r
 line 2\r
   \t \t   \t line 3\r
 line 4\r
Accept-Encoding: identity\r
Connection: Close\r
~~~\r
EOF
    return $req;
}

1;

package main;

Server::start();
Client::start();
Tests::start();

my $t = Test::Simple->new();
Tests::run($t);
Tests::wait();

Tests::stop();
Client::stop();
Server::stop();

Threads::join();

1;
