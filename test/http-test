#!/usr/bin/perl -w
package Config;
use strict;
use threads;
use threads::shared;

use Getopt::Long qw(:config bundling);
use Pod::Usage;
use Data::Dumper;

# defaults and non-CLI settings
my %CONFIG = (
    test => 'simple',
    listen_ip => '127.0.0.1',
    listen_port => '8080',
    proxy_address => 'localhost:9000',
    keep_alive => 1,
    server_threads => 1,
    client_threads => 1,
    raw_chunks_delay => 100, # usecs
    max_requests_default => 1,
    max_time  => 0,
    check_request => 1,
    check_response => 1
);

our @TESTS = (
    simple => 'Simple GET',
    raw => 'Raw GET, sent by small portions',
    raw_chunked => 'Raw POST with small chunked body',
    post_file => 'Send file in POST body',
    get_file => 'Send file in response body',
    post_chunked => 'Send large file in chunked POST body',
    all => 'Run all tests one by one'
);

my %TESTS = @TESTS;
for (my $i = $#TESTS; $i > 0; $i -= 2) {
    splice @TESTS, $i, 1;
}

my %OPTIONS = (
    # Format:
    # name          => ['aliases', 'type', 'description', 'dashed_variant'(generated)]
    test            => ['t', '=s', 'Test type to run'],
    list            => ['l', '', 'List test types'],
    server_address  => ['s', '=s', 'Bind HTTP server to specified IP:PORT'],
    proxy_address   => ['p', '=s', 'IP:PORT of tested HTTP proxy'],
    connect_address => ['c', '=s', 'Address to connect client to; defaults to --server-address'],
    no_proxy        => ['P', '', "Do not use proxy, instead send requests directly to server."],
    keep_alive      => ['k', '!', "Use persistent connections"],
    server_threads  => ['W', '=i', "Number of worker threads to spawn"],
    client_threads  => ['C', '=i', "Number of client threads to spawn"],
    max_requests    => ['n', '=i', "Number of requests to send"],
    max_time        => ['T', '=i', "Maximum time in seconds to run tests"],
    check_request   => ['chreq', '!', "Compare requests sent by client and received by server"],
    check_response  => ['chresp', '!', "Compare responses sent by server and received by client"],
    no_check        => ['nochk', '', "Same as: --no-check-request --no-check-response"],
    file            => ['f', '=s', "Existing file that will be read by some tests"],
    exit_running    => ['X', '', "If can't bind HTTP server, try to stop the running one"],
    quiet           => ['q', '', 'Quiet operation'],
    verbose         => ['v', '+', 'Verbose operation'],
    dump            => ['D', '+', 'Dump state at certain runpoint'],
);

use constant {
    ALIASES     => 0,
    TYPE        => 1,
    DESCRIPTION => 2,
    DEFAULT     => 3,
    DASHED      => 4
};

my @GETOPT_OPTS = map {
    my $specifier = $_;
    my $dashed = $_;
    my $aliases = $OPTIONS{$_}->[ALIASES];

    $specifier .= "|${dashed}"
        if $dashed =~ s/_/-/g;
    $specifier .= "|${aliases}"
        if $aliases;
    $specifier .= $OPTIONS{$_}->[TYPE];

    $OPTIONS{$_}->[DASHED] = $dashed;
    $specifier
} keys %OPTIONS;

sub new
{
    my $class = shift;
    $class = (ref $class || $class || __PACKAGE__);
    return bless {} => $class;
}

my $singleton = Config->new();
share($singleton);
%$singleton = %CONFIG;
$singleton->get_options();

sub get
{
    return $singleton;
}

sub require_options
{
    my $c = shift;
    my @missed = grep {
        not defined $c->{$_}
    } @_;
    if (@missed) {
        die "Required options missed: ", join(", ", map("--$_", @missed)), "\n";
    }
}

sub dump
{
    my $c = shift;
    $c->{dump} or return $c;

    my @dump;
    my %save;
    while ($_ = shift) {
        if (! ref $_ && s/^-//) {
            $save{$_} = ${$Data::Dumper::{$_}};
            ${$Data::Dumper::{$_}} = shift;
            next;
        }
        push @dump, $_;
    }

    $c->{dump}--;
    for (@dump) {
        print Dumper($_);
    }
    if (!$c->{dump}) {
        exit 0;
    }

    for (keys %save) {
        ${$Data::Dumper::{$_}} = $save{$_};
    }

    return $c;
}

sub get_options
{
    my $c = shift;
    GetOptions ($c, @GETOPT_OPTS) or exit 1;

    if ($c->{help}) {
        tie *OUT, __PACKAGE__;
        my $fh = \*OUT;
        pod2usage(-output => $fh, -verbose => 99, -sections => 'SYNOPSIS|COMMANDS|OPTIONS');
    }

    $c->process_options();
    $c->dump($c);

    return $c;
}

sub process_options
{
    my $c = shift;
    if ($c->{list}) {
        for (sort keys %TESTS) {
            print $_, " ($TESTS{$_})\n";
        }
        exit 0;
    }
    if ($c->{server_address}) {
        my @l = split(':', $c->{server_address});
        $c->{listen_ip} = $l[0] if $l[0];
        $c->{listen_port} = $l[1] if $l[1];
    }

    $c->{server_address} = $c->{listen_ip}. ':'. $c->{listen_port};

    if ($c->{no_proxy}) {
        undef $c->{proxy_address};
    } else {
        $c->{proxy_url} = "http://". $c->{proxy_address}. "/";
    }

    if (! $c->{connect_address}) {
        $c->{connect_address} = $c->{server_address};
    }
    $c->{connect_url} = "http://". $c->{connect_address}. "/";

    if ($c->{no_check}) {
        $c->{check_request} = 0;
        $c->{check_response} = 0;
    }

    if (! exists $c->{max_requests}) {
        if ($c->{max_time} > 0) {
            $c->{max_requests} = 0;
        } else {
            $c->{max_requests} = $c->{max_requests_default};
        }
    }
    delete $c->{max_requests_default};

    if (not exists $TESTS{$c->{test}}) {
        die "No such test: $c->{test}\n";
    }
}

sub new_test
{
    my $c = shift;
    my $test = shift;
    my $class = "Test::". join '', map { ucfirst } split('_', ${test});
    if ($class->can('process_options')) {
        $class->process_options($c);
    }
    return $class->new();
}

sub run_condition
{
    my $c = shift;
    my $requests = shift;
    my $watch = shift;

    if ($c->{max_requests} && $requests >= $c->{max_requests}) {
        return 0;
    }
    if ($c->{max_time} && $watch->run_time > $c->{max_time}) {
        $c->{time_up} = 1;
        return 0;
    }
    return 1;
}

sub print
{
    my $c = shift;
    unless ($c->{quiet}) {
        print @_;
    }
}

sub verbose
{
    my $c = shift;
    if ($c->{verbose}) {
        print @_;
    }
}

1;

package Threads;
use strict;
use threads qw[stringify];

use Carp;

my @Threads;

sub start
{
    my $count = shift;
    for my $i (1..$count) {
        my $thr = threads->create(@_);
        push @Threads, $thr;
    }
}

sub join
{
    for my $thr (@Threads) {
        $thr->join();
    }
}

sub die
{
    carp @_;
    # threads->exit() if threads->can('exit');   # Thread friendly
    # TODO: clean die
    exit 1;
}

1;

package ClientConnFixed;
use HTTP::Daemon;
use base 'HTTP::Daemon::ClientConn';
use vars qw($VERSION @ISA $PROTO $DEBUG);

my $CRLF = "\015\012";   # "\r\n" is not portable
my $HTTP_1_0 = HTTP::Daemon::ClientConn::_http_version("HTTP/1.0");
my $HTTP_1_1 = HTTP::Daemon::ClientConn::_http_version("HTTP/1.1");

# In case of 'chunked' it will call $hook->chunk() on each chunk
# and will skip accumulating it in $r. Anything else is left intact
# from HTTP::Daemon::ClientConn.

sub get_body
{
    my $self = shift;
    my $r = shift;
    my $hook = shift;

    my $buf = ${*$self}{'httpd_rbuf'};
    my $timeout = ${*$self}{'io_socket_timeout'};
    my $fdset = ${*$self}{'httpd_fdset'};

    # Find out how much content to read
    my $te  = $r->header('Transfer-Encoding');
    my $ct  = $r->header('Content-Type');
    my $len = $r->header('Content-Length');

    # Act on the Expect header, if it's there
    for my $e ( $r->header('Expect') ) {
        if( lc($e) eq '100-continue' ) {
            $self->send_status_line(100);
            $self->send_crlf;
        }
        else {
            $self->send_error(417);
            $self->reason("Unsupported Expect header value");
            return;
        }
    }

    if ($te && lc($te) eq 'chunked') {
        # Handle chunked transfer encoding
    my $length = 0;
      CHUNK:
        while (1) {
            print STDERR "Chunked\n" if $DEBUG;
            if ($buf =~ s/^([^\012]*)\012//) {
                my $chunk_head = $1;
                unless ($chunk_head =~ /^([0-9A-Fa-f]+)/) {
                    $self->send_error(400);
                    $self->reason("Bad chunk header $chunk_head");
                    return;
                }
                my $size = hex($1);
                last CHUNK if $size == 0;

                my $missing = $size - length($buf) + 2; # 2=CRLF at chunk end
                # must read until we have a complete chunk
                while ($missing > 0) {
                    print STDERR "Need $missing more bytes\n" if $DEBUG;
                    my $n = $self->_need_more($buf, $timeout, $fdset);
                    return unless $n;
                    $missing -= $n;
                }
                $length += $hook->chunk(substr($buf, 0, $size));
                substr($buf, 0, $size+2) = '';
            }
            else {
                # need more data in order to have a complete chunk header
                return unless $self->_need_more($buf, $timeout, $fdset);
            }
        }

        $hook->chunks_done($r);
        # pretend it was a normal entity body
        $r->remove_header('Transfer-Encoding');
        $r->header('Content-Length', $length);

        my($key, $val);
      FOOTER:
        while (1) {
            if ($buf !~ /\012/) {
                # need at least one line to look at
                return unless $self->_need_more($buf, $timeout, $fdset);
            }
            else {
                $buf =~ s/^([^\012]*)\012//;
                $_ = $1;
                s/\015$//;
                if (/^([\w\-]+)\s*:\s*(.*)/) {
                    $r->push_header($key, $val) if $key;
                    ($key, $val) = ($1, $2);
                }
                elsif (/^\s+(.*)/) {
                    $val .= " $1";
                }
                elsif (!length) {
                    last FOOTER;
                }
                else {
                    $self->reason("Bad footer syntax");
                    return;
                }
            }
        }
        $r->push_header($key, $val) if $key;

    }
    elsif ($te) {
        $self->send_error(501);         # Unknown transfer encoding
        $self->reason("Unknown transfer encoding '$te'");
        return;

    }
    elsif ($len) {
        # Plain body specified by "Content-Length"
        my $missing = $len - length($buf);
        while ($missing > 0) {
            print "Need $missing more bytes of content\n" if $DEBUG;
            my $n = $self->_need_more($buf, $timeout, $fdset);
            return unless $n;
            $missing -= $n;
        }
        if (length($buf) > $len) {
            $r->content(substr($buf,0,$len));
            substr($buf, 0, $len) = '';
        }
        else {
            $r->content($buf);
            $buf='';
        }
    }
    elsif ($ct && $ct =~ m/^multipart\/\w+\s*;.*boundary\s*=\s*("?)(\w+)\1/i) {
        # Handle multipart content type
        my $boundary = "$CRLF--$2--";
        my $index;
        while (1) {
            $index = index($buf, $boundary);
            last if $index >= 0;
            # end marker not yet found
            return unless $self->_need_more($buf, $timeout, $fdset);
        }
        $index += length($boundary);
        $r->content(substr($buf, 0, $index));
        substr($buf, 0, $index) = '';

    }
    ${*$self}{'httpd_rbuf'} = $buf;

    $r;
}

sub get_headers
{
    my($self, $waker_fd) = @_;
    if (${*$self}{'httpd_nomore'}) {
        $self->reason("No more requests from this connection");
        return;
    }

    $self->reason("");
    my $buf = ${*$self}{'httpd_rbuf'};
    $buf = "" unless defined $buf;

    my $timeout = $ {*$self}{'io_socket_timeout'};
    my $fdset = "";
    vec($fdset, $self->fileno, 1) = 1;
    if ($waker_fd) {
        vec($fdset, $waker_fd, 1) = 1;
        ${*$self}{'waker_fd'} = $waker_fd;
    }
    ${*$self}{'httpd_fdset'} = $fdset;
    local($_);

  READ_HEADER:
    while (1) {
        # loop until we have the whole header in $buf
        $buf =~ s/^(?:\015?\012)+//;  # ignore leading blank lines
        if ($buf =~ /\012/) {  # potential, has at least one line
            if ($buf =~ /^\w+[^\012]+HTTP\/\d+\.\d+\015?\012/) {
                if ($buf =~ /\015?\012\015?\012/) {
                    last READ_HEADER;  # we have it
                }
                elsif (length($buf) > 16*1024) {
                    $self->send_error(413); # REQUEST_ENTITY_TOO_LARGE
                    $self->reason("Very long header");
                    return;
                }
            }
            else {
                last READ_HEADER;  # HTTP/0.9 client
            }
        }
        elsif (length($buf) > 16*1024) {
            $self->send_error(414); # REQUEST_URI_TOO_LARGE
            $self->reason("Very long first line");
            return;
        }
        print STDERR "Need more data for complete header\n" if $DEBUG;
        return unless $self->_need_more($buf, $timeout, $fdset);
    }
    if ($buf !~ s/^(\S+)[ \t]+(\S+)(?:[ \t]+(HTTP\/\d+\.\d+))?[^\012]*\012//) {
        ${*$self}{'httpd_client_proto'} = $HTTP_1_0;
        $self->send_error(400);  # BAD_REQUEST
        $self->reason("Bad request line: $buf");
        return;
    }
    my $method = $1;
    my $uri = $2;
    my $proto = $3 || "HTTP/0.9";
    $uri = "http://$uri" if $method eq "CONNECT";
    $uri = $HTTP::URI_CLASS->new($uri, $self->daemon->url);
    my $r = HTTP::Request->new($method, $uri);
    $r->protocol($proto);
    ${*$self}{'httpd_client_proto'} = $proto = HTTP::Daemon::ClientConn::_http_version($proto);
    ${*$self}{'httpd_head'} = ($method eq "HEAD");

    if ($proto >= $HTTP_1_0) {
        # we expect to find some headers
        my($key, $val);
      HEADER:
        while ($buf =~ s/^([^\012]*)\012//) {
            $_ = $1;
            s/\015$//;
            if (/^([^:\s]+)\s*:\s*(.*)/) {
                $r->push_header($key, $val) if $key;
                ($key, $val) = ($1, $2);
            }
            elsif (/^\s+(.*)/) {
                $val .= " $1";
            }
            else {
                last HEADER;
            }
        }
        $r->push_header($key, $val) if $key;
    }

    my $conn = $r->header('Connection');
    if ($proto >= $HTTP_1_1) {
        ${*$self}{'httpd_nomore'}++ if $conn && lc($conn) =~ /\bclose\b/;
    }
    else {
        ${*$self}{'httpd_nomore'}++ unless $conn &&
                                           lc($conn) =~ /\bkeep-alive\b/;
    }

    ${*$self}{'httpd_rbuf'} = $buf;
    return $r;
}

sub _need_more
{
    my $self = shift;
    #my($buf,$timeout,$fdset) = @_;
    my($timeout, $fdset) = @_[1,2];
    print STDERR "select(,,,$timeout)\n" if $DEBUG;
    my $n = select(my $rout = $fdset,undef,undef,$timeout);
    unless ($n) {
        $self->reason(defined($n) ? "Timeout" : "select: $!");
        return;
    }
    if (vec($rout, ${*$self}{'waker_fd'}, 1)) {
        print STDERR "Exiting by waker\n" if $DEBUG;
        return;
    }
    print STDERR "sysread()\n" if $DEBUG;
    $n = sysread($self, $_[0], 2048, length($_[0]));
    $self->reason(defined($n) ? "Client closed" : "sysread: $!") unless $n;
    $n;
}

1;

package Server;
use strict;
use threads;
use threads::shared;
use Storable qw[freeze thaw];

use HTTP::Daemon;
use HTTP::Response;
use HTTP::Status;
use Errno qw[:POSIX];

my $RunS :shared;
my %Daemon :shared;
my $DaemonFD :shared;

my ($WakerR, $WakerW);
my $WakerFD :shared;

my $d;

sub init
{
    my $c = Config::get();
    $d = HTTP::Daemon->new(
        LocalAddr => $c->{'listen_ip'},
        LocalPort => $c->{'listen_port'},
        ReuseAddr => 1
    ) or die $c->{server_address}. ": $!\n";
    $c->print("Started HTTP server at " . $d->url . "\n");

    %Daemon = %${\*$d};
    $DaemonFD = fileno($d);
    open my $fh, "+<&=$DaemonFD" or die "open: $!";
}

sub start
{
    my $c = Config::get();

    pipe $WakerR, $WakerW
        or die "pipe: $!";
    $WakerFD = $WakerR->fileno;

    $RunS = 1;
    Threads::start($c->{server_threads}, \&worker_thread);
}

sub get_daemon
{
    open my $fh, "+<&=$DaemonFD" or Threads::die "$!";
    my $d = bless $fh => 'HTTP::Daemon';
    %${\*$d} = %Daemon;
    return $d;
}

my %ResponsesSent :shared;

my $WorkerThreads :shared;
$WorkerThreads = 0;

sub worker_thread
{
    {lock $WorkerThreads;
    ++$WorkerThreads;}
    my $d = get_daemon();
    my $c = Config::get();

    loop:
    while ($RunS) {
        my $conn = $d->accept('ClientConnFixed');
        last loop if $!{EINVAL};
        Threads::die "accept: $!\n" unless $conn;

        $conn->autoflush(1);
        my $req;
        while ($req = $conn->get_headers($WakerFD)) {
            my $id = $req->header('X-Request-Id');
            unless (defined $id) {
                $c->verbose("S: no X-Request-Id!\n");
                last;
            }
            $c->verbose("S: got request ${id}\n");

            my $test = Tests::get_test($id);
            $conn->get_body($req, $test)
                or Threads::die "Server failed to parse body!\n";

            if ($c->{check_request}) {
                my $sent = Client::get_request($id)
                    or Threads::die "Can't get request ${id} from Client!";
                $test->check_request($sent, $req);
            }

            my ($ok, $resp) = $test->send_response($id, $conn);
            Threads::die "$!" unless $ok;

            if ($c->{check_response}) {
                if (ref $resp->{_content}) {
                    $resp->{_content} = "";
                }
                $resp = freeze $resp;
                lock %ResponsesSent;
                $ResponsesSent{$id} = $resp;
            }
        } # while ($conn->get_request())
        # FIXME: check errno
        shutdown($conn, 2);
        close $conn;
        $conn = undef;
    }
    {lock $WorkerThreads;
    --$WorkerThreads;}
}

use Time::HiRes 'usleep';

sub stop
{
    $RunS = 0;

    shutdown($d, 2);
    while ($WorkerThreads) {
        # NB:  doesn't read from pipe!
        # How this will behave on multiple threads?
        print $WakerW "1";
        $WakerW->flush;
        usleep 1;
    }
    close $WakerW;
    close $WakerR;
}

sub get_response
{
    my $id = shift;
    my $resp;
    {
        lock %ResponsesSent;
        $resp = $ResponsesSent{$id};
        delete $ResponsesSent{$id};
    }
    $resp = thaw $resp;
    return $resp;
}

=pod
@SIG{$_} = sub {
    $RUN = 0;
} for (qw[INT TERM HUP QUIT]);
=cut

1;

package Client;
use strict;
use LWP  5.825;
use Time::HiRes 'usleep';

use threads;
use threads::shared;
use Storable qw[freeze thaw];

my $RunC :shared;

use constant MAX_REQS => 1000;
my @CQueue :shared;
my $CQFreed :shared;
my %ReqSent :shared;

sub start
{
    $RunC = 1;
    Threads::start(Config::get()->{client_threads}, \&client_thread);
}

my $ClientThreads :shared;
$ClientThreads = 0;

sub push_req_sent
{
    my $req = $_[0];
    my $id = $_[3] || $req->header('X-Request-Id');
    my $frozen = freeze $req;
    {
        lock %ReqSent;
        $ReqSent{$id} = $frozen;
    }
    return undef;
}

use constant REQUEST_DONE => 1;

sub client_thread
{
    {lock $ClientThreads;
    ++$ClientThreads;}
    my $c = Config::get();

    loop:
    while ($RunC) {
        my $id;
        {
            lock @CQueue;
            cond_wait @CQueue
                until @CQueue || !$RunC;
            last loop unless $RunC;
            $id = shift @CQueue;
            if (@CQueue == MAX_REQS - 1) {
                lock $CQFreed;
                cond_signal $CQFreed;
            }
        }

        my $test = Tests::get_test($id);
        $test->send_init;
        my $resp = $test->send_request($id);
        Threads::die "$!" if $!;
        $resp->request(undef); # TODO: actually we don't need %ReqSent since we can pass req in resp

        if ($c->{check_response}) {
            my $sent = Server::get_response($id)
                or next;
            $test->check_response($sent, $resp);
        }
        Tests::checkpoint($id, REQUEST_DONE);
    }
    {lock $ClientThreads;
    --$ClientThreads;}
}

sub stop
{
    $RunC = 0;
    while ($ClientThreads) {
        lock @CQueue;
        cond_signal @CQueue;
    } continue {
        usleep 1;
    }
}

sub enqueue
{
    my $id = shift;
    lock @CQueue;
    cond_wait $CQFreed, @CQueue
        until @CQueue < MAX_REQS;
    push @CQueue, $id;
    cond_signal @CQueue;
}

sub clear_queue
{
    my @id;
    lock @CQueue;
    @id = @CQueue;
    @CQueue = ();
    return \@id;
}

sub get_request
{
    my $id = shift;
    my $req_sent;
    {
        lock %ReqSent;
        $req_sent = $ReqSent{$id};
        delete $ReqSent{$id};
    }
    $req_sent = thaw $req_sent;
    return $req_sent;
}

1;

package Stopwatch;
use Time::HiRes qw[gettimeofday tv_interval];

sub new
{
    my $class = shift;
    $class = (ref $class || $class);

    my $self = bless {
        start_time => shift,
        stop_time => undef,
        elapsed => undef
    } => $class;

    return $self;
}

sub start
{
    my $self = shift;
    $self->{start_time} = [gettimeofday];
}

sub start_time
{
    my $self = shift;
    return ref $self->{start_time} eq __PACKAGE__ ?
        $self->{start_time}->start_time() :
        $self->{start_time};
}

sub stop
{
    my $self = shift;
    $self->{stop_time} = [gettimeofday];
    $self->{elapsed} = tv_interval($self->start_time, $self->{stop_time});
}

sub print
{
    my $self = shift;
    my $reqs = shift;
    my $elpsd = $self->{elapsed};
    my $reqs_per_sec = $reqs / $elpsd;
    {
        use integer;
        $reqs_per_sec /= 1;
    }
    Config::get->print("Finished in $elpsd secs; $reqs_per_sec requests/sec\n");
}

sub run_time
{
    my $self = shift;
    return wantarray ?
        tv_interval($self->start_time, [gettimeofday]) :
        time - $self->start_time->[0];
}

1;

package Tests;
use strict;

use HTTP::Status;

use threads;
use threads::shared;
use Storable qw[freeze thaw];

my $ReqId = 0;
my $ReqDone :shared;
$ReqDone = 0;
my %Tests :shared;

my $Watch = Stopwatch->new();

sub run
{
    my $test = shift;
    my $c = Config::get();

    $c->print("Test: ${test}, started...\n");

    $Watch->start;

    for (my $n = 0; $c->run_condition($n, $Watch); ++$n) {
        {
            lock %Tests;
            $Tests{$ReqId} = $test;
        }

        # client queue will block until less than MAX_REQS
        Client::enqueue($ReqId);
        $ReqId++;
    }
    if ($c->{time_up}) {
        my $cleared = Client::clear_queue();
        lock %Tests;
        for my $id (@$cleared) {
            delete $Tests{$id};
        }
        cond_signal %Tests;
    }
}

sub wait
{
    lock %Tests;
    cond_wait %Tests
        while %Tests;

    $Watch->stop;
    $Watch->print($ReqDone);
}

sub checkpoint
{
    my $id = shift;
    my $done = shift;
    if ($done) {
        ++$ReqDone;
        lock %Tests;
        delete $Tests{$id};
        cond_signal %Tests;
    }
}

sub get_test
{
    my $id = shift;
    my $test = $Tests{$id};
    die "No test for req ${id}" unless $test;
    my $c = Config::get;
    my $t = $c->new_test($test);
    $t->{id} = $id;
    return $t;
}

use Time::HiRes 'usleep';

my %ignored = (
    'transfer-encoding' => 1,
    'connection' => 1
);

sub check_message
{
    my $sent = shift;
    my $got = shift;

    my $type = ref $sent eq 'HTTP::Request' ? 'request' : 'response';

    for my $name ($sent->header_field_names) {
        next if $ignored{lc $name};
        my $val = $got->header($name);
        if (not defined $val) {
            Threads::die "Received ${type} lacks header ${name}!\n";
        }
        my $expected = $sent->header($name);
        $expected =~ s/[\r\n\t ]+/ /gm; # multi-line headers are catenated in HTTP::Daemon
        if ($val ne $expected) {
            Threads::die "Wrong ${type} header ${name}: ${val}, expected ${expected}\n";
        }
    }
    my $sent_content = $sent->content;
    my $got_content = $got->content;
    my $sent_len = length $sent_content;
    my $got_len = length $got_content;
    if ($sent_len != $got_len) {
        Threads::die "Wrong ${type} body size: ${got_len}, expected ${sent_len}\n";
    }
    if ($sent_content ne $got_content) {
        Threads::die "Wrong ${type} body content!\n";
    }
}

1;

package Test::Simple;
use strict;

use HTTP::Request::Common;
use HTTP::Response;
use HTTP::Status;

sub new
{
    my $class = shift;
    my $option = shift;
    $class = (ref $class || $class);

    my $self = bless {} => $class;

    return $self;
}

sub send_init
{
    my $self = shift;
    my $c = Config::get();

    my $ua = LWP::UserAgent->new(keep_alive => $c->{keep_alive});
    if ($c->{proxy_address}) {
        $ua->proxy('http', $c->{'proxy_url'});
    }

    if ($c->{check_request}) {
        $ua->add_handler(request_send => \&Client::push_req_sent);
    }
    $self->{ua} = $ua;
    return $self;
}

sub send_request
{
    my $self = shift;
    my $id = shift;
    my $ua = $self->{ua};
    my $req = $self->build_request($id);
    return $ua->request($req);
}

sub send_response
{
    my $self = shift;
    my $id = shift;
    my $conn = shift;
    my $resp = $self->build_response($id);
    return ($conn->send_response($resp), $resp);
}

sub build_request
{
    my $self = shift;
    my $id = shift;
    my $c = Config::get();
    my $req = GET($c->{connect_url}, X_Request_Id => $id);
    return $req;
}

sub build_response
{
    my $self = shift;
    my $request_id = shift;

    my $body = "OK\n";

    return HTTP::Response->new(
        RC_OK,
        undef,
        [
            'X-Request-Id' => $request_id,
            'Content-Type' => 'text/plain',
            'Cache-Control' => 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0',
            'Pragma' => 'no-cache',
            'Expires' => 'Thu, 01 Dec 1994 16:00:00 GMT',
            'Content-Length' => length $body
        ],
        $body
    );
}

sub check_request
{
    my $self = shift;
    my $sent = shift;
    my $req = shift;

    Tests::check_message($sent, $req);
}

sub check_response
{
    my $self = shift;
    my $sent = shift;
    my $resp = shift;

    if ($resp->code ne RC_OK) {
        Threads::die "Unexpected response: ". $resp->message. " (". $resp->code. ")\n";
    }
    Tests::check_message($sent, $resp);
}

1;

package Test::Raw;
use parent 'Test::Simple';
use strict;

use HTTP::Request;
use HTTP::Response;
use Socket qw[:all];
use Time::HiRes qw[usleep];

sub send_init
{
    return $_[0];
}

sub push_req_sent
{
    shift;
    Client::push_req_sent(@_);
}

sub send_request
{
    my $self = shift;
    my $id = shift;

    my $c = Config::get();
    my $req_raw = $self->build_request($id);
    my @chunks = split('~~~', $req_raw);
    my $req = HTTP::Request->parse(join('', @chunks));

    if ($c->{check_request}) {
        $self->push_req_sent($req, undef, undef, $id);
    }

    my $host = $req->header('Host');
    my $sock = IO::Socket::INET->new(
        PeerAddr => $c->{proxy_address} ? $c->{proxy_address} : $req->header('Host'),
        Proto => 'tcp'
    ) or Threads::die "connect: $!";
    setsockopt($sock, IPPROTO_TCP, TCP_NODELAY, 1);
    for my $chunk (@chunks) {
        $sock->send($chunk);
        usleep $c->{raw_chunks_delay};
    }
    my $resp_raw;
    my $buf;
    do {
        defined $sock->recv($buf, 4096)
            or Threads::die "recv: $!";
        $resp_raw .= $buf;
    } while (length($buf));
    # TODO: check errno
    my $resp = HTTP::Response->parse($resp_raw);
    return $resp;
}

sub build_request
{
    my $self = shift;
    my $request_id = shift;
    my $c = Config::get();
    my $req =<<EOF;
GET / HTTP/1.1\r
User-Agent: Wget/1.17.1 (cygwin)\r
Accept: */*\r
Host: $c->{connect_address}\r
X-Request-Id: ${request_id}\r
X-Multi-Line-Header: line 1\r
 line 2\r
   \t \t   \t line 3\r
 line 4\r
Accept-Encoding: identity\r
Connection: Close\r
~~~\r
EOF
    return $req;
}

1;

package Test::RawChunked;
use base 'Test::Raw';

sub new
{
    my $class = shift;
    $class = (ref $class || $class);

    my $self = bless {
        body => ""
    } => $class;

    return $self;
}

sub build_request
{
    my $self = shift;
    my $request_id = shift;
    my $c = Config::get();
    my $req =<<EOF;
POST / HTTP/1.1\r
User-Agent: Wget/1.17.1 (cygwin)\r
Accept: */*\r
Accept-Encoding: identity\r
Host: $c->{connect_address}\r
X-Request-Id: ${request_id}\r
Connection: Close\r
Transfer-Encoding: chunked\r
\r
4\r
abc
\r
0\r
X-Trailer-Header: nothing\r
X-Trailer-Header2: something\r
\r
EOF
    return $req;
}

sub push_req_sent
{
    my $self = shift;
    my $req = shift;
    # HTTP::Request can't parse chunked body
    $req->content("abc\n");
    $req->header('X-Trailer-Header', 'nothing');
    $req->header('X-Trailer-Header2', 'something');
    Client::push_req_sent($req, @_);
}

sub chunk
{
    my $self = shift;
    my $chunk = shift;
    $self->{body} .= $chunk;
    return length($chunk);
}

sub chunks_done
{
    my $self = shift;
    my $req = shift;
    $req->content($self->{body});
}

1;

package Test::PostFile;
use base 'Test::Simple';

use HTTP::Request::Common;

sub process_options
{
    my $class = shift;
    my $c = shift;
    die "post_file requires valid --file option!\n"
        unless $c->{file} && -f $c->{file};
}

sub build_request
{
    my $self = shift;
    my $id = shift;
    my $c = Config::get();
    my $req = POST(
        $c->{connect_url},
        Content_Type => 'multipart/form-data',
        Content      => [ file => [ $c->{file} ] ],
        X_Request_Id => $id
    );
    return $req;
}

sub chunk
{
    my $self = shift;
    my $chunk = shift;
    return length($chunk);
}

sub chunks_done
{
    my $self = shift;
    my $req = shift;
}

1;

package Test::GetFile;
use base 'Test::Simple';

use HTTP::Response;
use HTTP::Status;

sub process_options
{
    my $class = shift;
    my $c = shift;
    die "get_file requires valid --file option!\n"
        unless $c->{file} && -f $c->{file};
}

sub build_response
{
    my $self = shift;
    my $request_id = shift;
    my $c = Config::get();

    open my $fh, "<", $c->{file}
        or Threads::die "$!";

    $self->{fh} = $fh;

    return HTTP::Response->new(
        RC_OK,
        undef,
        [
            'X-Request-Id' => $request_id,
            Content_Type => 'application/octet-stream'
        ],
        sub {
            return $self->next_chunk();
        }
    );
}

sub next_chunk
{
    my $self = shift;
    my $fh = $self->{fh};

    my ($len, $buf);
    $len = sysread $fh, $buf, 4096;
    if ($len < 0) {
        Threads::die "sysread: $!";
    }
    if ($len > 0) {
        return $buf;
    }
    close $fh;
    return undef;
}

sub check_response
{
    my $self = shift;
    my $sent = shift;
    my $got = shift;
}

1;

package Test::PostChunked;
use base 'Test::PostFile';

use threads;
use threads::shared;

use Net::HTTP;
use HTTP::Request;
use HTTP::Response;

my $SendBufW :shared;
my $SendBufR :shared;
my %SendBuf :shared;

sub send_init
{
    return $_[0];
}

sub send_request
{
    my $self = shift;
    my $id = shift;
    my $c = Config::get;
    my $ua = $self->{ua} || ($self->{ua} =
        Net::HTTP->new(
            Host => $c->{proxy_address} ? $c->{proxy_address} : $c->{connect_address},
            KeepAlive => $c->{keep_alive}))
        or Threads::die "connect: $!";

    {
        my @method_url = (POST => '/');
        my @headers = (
            Host => $c->{connect_address},
            'User-Agent' => "Mozilla/5.0",
            'Content-Type' => 'application/octet-stream',
            'Transfer-Encoding' => 'chunked',
            'X-Request-Id' => $id);

        $ua->write_request(@method_url, @headers)
            or Threads::die "write_request() failed!";

        if ($c->{check_request}) {
            Client::push_req_sent(HTTP::Request->new(@method_url, \@headers), undef, undef, $id);
        }

        open my $fh, "<", $c->{file}
            or Threads::die "$!";

        my ($len, $buf);
        while ($len = sysread $fh, $buf, 4096) {
            $ua->write_chunk($buf) or
                Threads::die "write_chunk() failed!";

            my $err = $!;
            if ($c->{check_request}) {
                lock %SendBuf;
                cond_wait $SendBufW, %SendBuf
                    while exists $SendBuf{$id};
                $SendBuf{$id} = $buf;
                lock $SendBufR;
                cond_signal $SendBufR;
            }
        }

        close $fh;
        $ua->write_chunk_eof() or
            Threads::die "write_chunk_eof() failed!";
    }

    my $resp;
    {
        my ($code, $mess, @headers) = $ua->read_response_headers();
        my ($body, $data);
        while ($ua->read_entity_body($data, 4096)) {
            $body .= $data;
        }
        $resp = HTTP::Response->new($code, $mess, \@headers, $body);
    }
    return $resp;
}

sub chunk
{
    my $self = shift;
    my $chunk = shift;
    my $got_len = length $chunk;
    return $got_len
        unless Config::get->{check_request};

    my $id = $self->{id};
    my $sent;
    {    
        lock %SendBuf;
        cond_wait $SendBufR, %SendBuf
            until exists $SendBuf{$id};
        $sent = $SendBuf{$id};
        delete $SendBuf{$id};
        lock $SendBufW;
        cond_signal $SendBufW;
    }

    my $sent_len = length $sent;
    if ($sent_len != $got_len) {
        Threads::die "Wrong request chunk size: ${got_len}, expected ${sent_len}\n";
    }
    if ($sent ne $chunk) {
        Threads::die "Request chunk content mismatch!\n";
    }

    return $got_len;
}

1;

package main;
use Config;

my $c = Config::get();

my @tests;
if ($c->{test} eq 'all') {
    push @tests, grep {
        $_ ne 'all'
    } @Config::TESTS;
} else {
    push @tests, $c->{test};
}

Server::init();
Server::start();
Client::start();

for my $t (@tests) {
    Tests::run($t);
    Tests::wait();
}

Client::stop();
Server::stop();

Threads::join();

1;
